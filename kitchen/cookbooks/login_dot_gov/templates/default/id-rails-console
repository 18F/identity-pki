#!/bin/bash

# Enable the 'monitor' shell option, which allows background jobs to be monitored by the shell.
# Setup an empty trap for common signals (SIGHUP, SIGINT, SIGQUIT, SIGTERM, SIGSTOP, and SIGTSTP)
# to prevent being able to drop into a shell from the ssm document
set -o monitor
trap '' 1 2 3 15 19 20

set -eu

app=""
APP_USER="${APP_USER-websrv}"
CONSOLE_INFO=()

ENV_VARS=()
LOGIN_TASK_LOG_LEVEL='warn'

usage() {
  cat >&2 <<EOM

usage: $(basename "$0") [-l|--log LEVEL] [-w|--write] [APP]

Run a Rails console for APP (default "idp").

This involves using sudo to change to the app service user, default $APP_USER.
(Override by setting APP_USER). You will be prompted to provide a justification
for creating this console, which will be recorded in the $CHANNEL
channel in Slack.
The -l / --log flag can be used, along with a LEVEL, to change the
value of LOGIN_TASK_LOG_LEVEL that is sent to the rake task;
this defaults to 'warn' if not set.

Flags:
  -w | --write      : Passes ALLOW_CONSOLE_DB_WRITE_ACCESS="true" env var
                      through to rails console
  -l | --log LEVEL  : Passes LOGIN_TASK_LOG_LEVEL env var (set to LEVEL)
                      through to rails console (defaults to WARN if not set)

EOM
}

MISSING_KEYS=0
CHANNEL_FILES=(
  /etc/login.gov/keys/slackchannel
)

# Check for missing slack settings
for file in "${CHANNEL_FILES[@]}"
do
  CHANNEL_FILE=$(cat "$file") || ((MISSING_KEYS++))
done
WEBHOOK=$(cat /etc/login.gov/keys/slackwebhook) || ((MISSING_KEYS++))
if [ ${MISSING_KEYS} -gt 0 ]; then
  echo 'Slack channel/webhook missing! Verify files and run Chef to repopulate.'
  exit 1
fi

ID_USER=$(whoami) || true
if [[ "${ID_USER}" =~ ^(root|ssm-user|ubuntu|ec2-user|websrv|appinstall) ]] || [ -z "$ID_USER" ] ; then
  ID_USER="${GSA_USERNAME:-}"
  if [ -z "$ID_USER" ] ; then
    echo 'Username invalid! Set via GSA_USERNAME env var or SSMSessionRunAs session tag'
    exit 1
  fi
fi

while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help)
      usage
      exit
    ;;
    -l|--log)
      LOGIN_TASK_LOG_LEVEL="$2"
      shift
    ;;
    -w|--write)
      ALLOW_CONSOLE_DB_WRITE_ACCESS="true"
    ;;
    *)
      app="$1"
    ;;
  esac
  shift
done

if [[ -n "$app" && ! -d "/srv/${app}/current" ]] ; then
  echo "Directory '/srv/${app}/current' not found! Verify app name and run again"
  exit 1
elif [[ -z "$app" ]] ; then
  found_app=$(find /srv -maxdepth 2 -name "current" -type l 2>/dev/null | head -n 1 | cut -d/ -f 3)
  if [[ -z "$found_app" ]]; then
    echo "Cound not find a /srv/*/current symlink"
    exit 1
  fi
  app="$found_app"
fi

ENV_VARS+=("app=$app")

# Pass through ALLOW_CONSOLE_DB_WRITE_ACCESS, if set
if [ -n "${ALLOW_CONSOLE_DB_WRITE_ACCESS-}" ]; then
  CONSOLE_INFO+=('(readwrite)')
  ENV_VARS+=("ALLOW_CONSOLE_DB_WRITE_ACCESS=$ALLOW_CONSOLE_DB_WRITE_ACCESS")
else
  CONSOLE_INFO+=('(readonly)')
fi

while true; do
  read -r -p "Please provide an explanation for this Rails console: " USE_CASE
  if [ ! -z "$USE_CASE" ]; then
    break
  fi
done
CONSOLE_INFO+=($(printf ":\n *%s*" "$USE_CASE"))

if [[ ! "${LOGIN_TASK_LOG_LEVEL}" =~ ^(debug|info|warn|error|fatal|unknown)$ ]] ; then
  LOGIN_TASK_LOG_LEVEL='warn'
  echo "LOGIN_TASK_LOG_LEVEL of '${LOGIN_TASK_LOG_LEVEL}' invalid; defaulting to WARN"
fi
ENV_VARS+=("LOGIN_TASK_LOG_LEVEL=$LOGIN_TASK_LOG_LEVEL")

# Send message to slack first since we dont need console output
TEXT=':rails: _console_ :rails: for `'"${ID_USER}"'` on `'"$(hostname)"'` '"${CONSOLE_INFO[@]:-}"''

# Loop over channel files and send message to each designated channel
for FILE in "${CHANNEL_FILES[@]}"
do
  CHANNEL=$(cat "${FILE}")
  sudo -u "$APP_USER" notify-slack --channel "$CHANNEL" --webhook "$WEBHOOK" --username "id-rails-console" --icon "dopetopus" --text "$TEXT"
done

# Execute console command
exec sudo -H -u "$APP_USER" env "${ENV_VARS[@]}" sh -euxc "trap '' 1 2 3 15 19 20 ; cd '/srv/$app/current'; bundle exec rails console"
