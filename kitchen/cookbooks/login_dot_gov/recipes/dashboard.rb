# setup postgres root config resource
psql_config 'configure postgres root cert'

app_name = 'dashboard'

include_recipe 'login_dot_gov::dhparam'

base_dir = "/srv/#{app_name}"
deploy_dir = "#{base_dir}/current/public"

basic_auth_enabled = !!ConfigLoader.load_config_or_nil(node, "basic_auth_user_name")

idp_url = "https://idp.#{node.chef_environment}.#{node['login_dot_gov']['domain_name']}"
if basic_auth_enabled
  basic_auth_username = ConfigLoader.load_config(node, "basic_auth_user_name")
  basic_auth_password = ConfigLoader.load_config(node, "basic_auth_password")
  idp_sp_url = "https://#{basic_auth_username}:#{basic_auth_password}@idp.#{node.chef_environment}.#{node['login_dot_gov']['domain_name']}/api/service_provider"
else
  idp_sp_url = "https://idp.#{node.chef_environment}.#{node['login_dot_gov']['domain_name']}/api/service_provider"
end
dashboard_url = "https://dashboard.#{node.chef_environment}.#{node.fetch('login_dot_gov').fetch('domain_name')}"

branch_name = node.fetch('login_dot_gov').fetch('branch_name', "stages/#{node.chef_environment}")

%w{cached-copy config log}.each do |dir|
  directory "#{base_dir}/shared/#{dir}" do
    group node['login_dot_gov']['system_user']
    owner node.fetch(:passenger).fetch(:production).fetch(:user)
    recursive true
    subscribes :create, "deploy[/srv/dashboard]", :before
  end
end

# TODO: don't generate YAML with erb, that's an antipattern
template "#{base_dir}/shared/config/database.yml" do
  owner node['login_dot_gov']['system_user']
  sensitive true
  variables({
    database: 'dashboard',
    username: ConfigLoader.load_config(node, "db_username_app"),
    host: ConfigLoader.load_config(node, "db_host_app"),
    password: ConfigLoader.load_config(node, "db_password_app"),
    sslmode: 'verify-full',
    sslrootcert: '/usr/local/share/aws/rds-combined-ca-bundle.pem'
  })
end

# custom resource to configure new relic (newrelic.yml)
login_dot_gov_newrelic_config "#{base_dir}/shared" do
  not_if { node['login_dot_gov']['setup_only'] }
  app_name "dashboard.#{node.chef_environment}.#{node.fetch('login_dot_gov').fetch('domain_name')}"
end

dashboard_config = {
  'dashboard_api_token' => ConfigLoader.load_config(node, "dashboard_api_token"),
  'idp_url' => idp_url,
  'idp_sp_url' => idp_sp_url,

  # Some of these SAML values are unused, some are actually used for OIDC. They
  # should each be either removed or renamed to reflect their actual purpose
  # now that the dashboard uses OIDC.
  # https://github.com/18F/identity-dashboard/issues/194
  'saml_sp_certificate' => 'not-actually-used',
  'saml_sp_issuer' => dashboard_url, # TODO rename
  'saml_sp_private_key' => ConfigLoader.load_config_or_nil(node, "dashboard_sp_private_key") || node['login_dot_gov']['dashboard']['sp_private_key'],
  'saml_sp_private_key_password' => ConfigLoader.load_config_or_nil(node, "dashboard_sp_private_key_password") || node['login_dot_gov']['dashboard']['sp_private_key_password'],

  'secret_key_base' => ConfigLoader.load_config(node, "secret_key_base_dashboard"),

  # https://github.com/18F/identity-dashboard/issues/196
  # TODO remove or fix these
  'smtp_address' => 'unused', # TODO unused
  'smtp_domain' => dashboard_url, # TODO unused
  'smtp_password' => 'sekret', # TODO unused
  'smtp_username' => 'user', # TODO unused
  'mailer_domain' => dashboard_url,
}

if basic_auth_enabled
  dashboard_config['basic_auth_username'] = basic_auth_username
  dashboard_config['basic_auth_password'] = basic_auth_password
end

# Application configuration (application.yml)
file "#{base_dir}/shared/config/application.yml" do
  owner node.fetch('login_dot_gov').fetch('system_user')
  group node.fetch('login_dot_gov').fetch('web_system_user')
  mode '0640'
  sensitive true
  content("# Generated by chef from #{__FILE__}\n" +
          {'production' => dashboard_config}.to_yaml)
  subscribes :create, 'deploy[/srv/dashboard]', :immediately
end

deploy "#{base_dir}" do
  action :deploy

  before_symlink do
    execute "cp #{base_dir}/shared/config/application.yml #{release_path}/config/application.yml"
    # cp generated configs from chef to the shared dir on first run
    app_config = "#{base_dir}/shared/config/secrets.yml"
    unless File.exist?(app_config) && File.symlink?(app_config) || node['login_dot_gov']['setup_only']
      execute "cp #{release_path}/config/secrets.yml #{base_dir}/shared/config"
    end

    cmds = [
      "rbenv exec bundle config build.nokogiri --use-system-libraries",
      "rbenv exec bundle install --deployment --jobs 3 --path #{base_dir}/shared/bundle --without deploy development test",
      "rbenv exec bundle exec rake assets:precompile",
    ]

    cmds.each do |cmd|
      execute cmd do
        cwd release_path
        environment ({
          'RAILS_ENV' => 'production',
        })
      end
    end
  end

  repo 'https://github.com/18F/identity-dashboard.git'
  branch branch_name
  shallow_clone true
  keep_releases 1
  
  symlinks ({
    'config/database.yml' => 'config/database.yml',
    'config/newrelic.yml' => 'config/newrelic.yml',
    'config/application.yml' => 'config/application.yml',
    "log" => "log",
  })
end

execute "rbenv exec bundle exec rake db:create db:migrate --trace" do
  cwd "#{base_dir}/current"
  environment({
    'RAILS_ENV' => "production"
  })
  user node['login_dot_gov']['system_user']
end

if basic_auth_enabled
  basic_auth_config 'generate basic auth config' do
    password  "#{basic_auth_password}"
    user_name "#{basic_auth_username}"
  end
end

# Create a self-signed certificate for ALB to talk to. ALB does not verify
# hostnames or care about certificate expiration.
key_path = "/etc/ssl/private/#{app_name}-key.pem"
cert_path = "/etc/ssl/certs/#{app_name}-cert.pem"

# rely on instance_certificate cookbook being present to generate a self-signed
# keypair
link key_path do
  to node.fetch('instance_certificate').fetch('key_path')
end
link cert_path do
  to node.fetch('instance_certificate').fetch('cert_path')
end

# add nginx conf for app server
# TODO: JJG convert security_group_exceptions to hash so we can keep a note in both chef and nginx
#       configs as to why we added the exception.
template "/opt/nginx/conf/sites.d/dashboard.login.gov.conf" do
  owner node['login_dot_gov']['system_user']
  notifies :restart, "service[passenger]"
  source 'nginx_server.conf.erb'

  variables({
    app: app_name,
    domain: "#{node.chef_environment}.#{node['login_dot_gov']['domain_name']}",
    passenger_ruby: lazy { Dir.chdir(deploy_dir) { shell_out!(%w{rbenv which ruby}).stdout.chomp } },
    security_group_exceptions: ConfigLoader.load_config(node, "security_group_exceptions"),
    server_name: "#{app_name}.#{node.chef_environment}.#{node['login_dot_gov']['domain_name']}"
  })
end

directory "#{deploy_dir}/api" do
  owner node.fetch('login_dot_gov').fetch('system_user')
  recursive true
  action :create
end

login_dot_gov_deploy_info "#{deploy_dir}/api/deploy.json" do
  owner node.fetch('login_dot_gov').fetch('system_user')
  branch branch_name
end

# After doing the full deploy, we need to fully restart passenger in order for
# it to actually be running. This seems like a bug in our chef config. The main
# service[passenger] restart seems to attempt a graceful restart that doesn't
# actually work.
# TODO don't do this, figure out how to get passenger/nginx to be happy
Chef.event_handler do
  on :run_completed do
    Chef::Log.info('Starting handler for passenger restart hack')
    if system('pgrep -a "^Passenger"')
      Chef::Log.info('Found running Passenger process, skipping hack')
    else
      Chef::Log.warn('Restarting passenger as hack to finish startup')
      if system('service passenger restart')
        Chef::Log.warn('OK, restarting passenger succeeded')
      else
        Chef::Log.warn('FAIL, restarting passenger failed')
      end
    end
  end
end
