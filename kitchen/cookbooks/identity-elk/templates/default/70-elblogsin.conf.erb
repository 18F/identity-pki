input {
   s3 {
     bucket => "<%= @elb_logging_bucket %>"
     prefix => "<%= @elb_prefix %>"
     proxy_uri => "<%= @proxy_uri -%>"
     region => "<%= @aws_region %>"
     sincedb_path => "/usr/share/logstash/.sincedb_elb"
     type => "elb"
   }
}

filter {
  if [message] =~ "^h2|http|https|ws|wss" {
    grok {
      # add type field
      add_field => { "type" => "alb" }
      # match according to https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-access-logs.html#access-log-entry-syntax
      match => { "message" => "\A%{WORD:request_type} %{TIMESTAMP_ISO8601:timestamp} %{NOTSPACE:elb} %{HOSTPORT:clientport} (%{HOSTPORT:targetport}|%{NOTSPACE:targetport_other}) (%{ISO8601_SECOND:request_processing_time}|%{NOTSPACE:request_processing_time_other}) (%{ISO8601_SECOND:target_processing_time}|%{NOTSPACE:target_processing_time_other}) (%{ISO8601_SECOND:response_processing_time}|%{NOTSPACE:response_processing_time_other}) %{INT:elb_status_code} (%{INT:target_status_code}|-) %{INT:received_bytes} %{INT:sent_bytes} %{QS:request} %{QS:user_agent} (%{NOTSPACE:ssl_cipher}|-) (%{NOTSPACE:ssl_protocol}|-) %{NOTSPACE:target_group_arn} %{QS:trace_id} %{QS:domain_name} %{QS:chosen_cert_arn} (%{NOTSPACE:matched_rule_priority}|-) %{TIMESTAMP_ISO8601:request_creation_time} (%{NOTSPACE:actions_executed}|-) (%{NOTSPACE:redirect_uri}|-)" }
    }
    date {
      # further parse timestamp field according to ISO8601 pattern (currently it's just a string from ^^)
      match  => [ "timestamp", ISO8601 ]
    }
    mutate {
      # remove quotes from quoted strings
      gsub => [
        "actions_executed", '"', "",
        "chosen_cert_arn", '"', "",
        "domain_name", '"', "",
        "redirect_uri", '"', "",
        "request", '"', "",
        "trace_id", '"', "",
        "user_agent", '"', ""
      ]
    }
    grok {
        # further parse the request string into method, uri, and http version
        match => ["request", "(%{NOTSPACE:http_method})? (%{NOTSPACE:http_uri})? (%{NOTSPACE:http_version})?"]
    }
    grok {
        # further parse http_uri into protocol, domain, port, and uri.
        match => ["http_uri", "(%{WORD:protocol})?(://)?(%{IPORHOST:domain})?(:)?(%{INT:http_port})?(%{GREEDYDATA:request_uri})?"]
    }
    grok {
        # further parse client
        match => ["client", "(%{IPORHOST:client_ip})?"]
    }
    geoip {
        # perform a geoip lookup on the client ip
        source => "client_ip"
    }
  }
  if [type] == "elb" {
    grok {
      add_field => { "type" => "clb" }
      match => { "message" => '%{TIMESTAMP_ISO8601:timestamp} %{NOTSPACE:elb_name} %{IP:elb_client_ip}:%{NUMBER:elb_client_port} %{IP:elb_backend_ip}:%{NUMBER:elb_backend_port} %{NUMBER:request_processing_time} %{NUMBER:backend_processing_time} %{NUMBER:response_processing_time} (?:%{NUMBER:elb_status_code}|-) (?:%{NUMBER:backend_status_code}|-) %{NUMBER:elb_received_bytes} %{NUMBER:elb_sent_bytes} "(?:%{QS:elb_request}|- - - )" "(?:%{QS:userAgent}|-)" %{NOTSPACE:elb_sslcipher}|- %{NOTSPACE:elb_sslprotocol}|-' }
    }
  }
}
