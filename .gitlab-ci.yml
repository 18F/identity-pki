---
# Jobs defined here use the ecr-public/docker/library/alpine docker image by
# default. To find other available images:
#   aws ecr describe-repositories | jq '.repositories[].repositoryUri'
#
# To use a publicly-available image via an ECR pull-through cache:
#   Locate the image at https://gallery.ecr.aws/ and note the path, e.g. docker/library/alpine
#   Prefix 'ecr-public/' to the path, e.g. ecr_path=ecr-public/docker/library/alpine
#   Add $ecr_path to terraform/ecr/tooling-prod/repos.yml and tf apply.
#   Use the image in your CI jobs as:
#     image: "${ECR_REGISTRY}/$ecr_path"
#
# To build an image from a Dockerfile:
#   Make up a name for your image's repo.
#   Add it to terraform/ecr/tooling-prod/repos.yml and tf apply.
#   Add the dockerfile to dockerfiles/
#   Build it by adding a job like so:
#     build_pivcac_ci:
#       extends: .build_template
#       variables:
#         dockerfile: pivcac_ci.Dockerfile
#         ecr_repo: pivcac/ci

stages:
  - build
  - pre_deploy_test
  - deploy
  - post_deploy
  - test
  - scan
  - gitlabproduction_deploy

variables:
  CI_COMMIT_TAG: "$CI_COMMIT_SHA"
  ECR_REGISTRY: "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com"
  # These are hardcoded to make this deploy process more secure.
  # If you want to update these images, you will need to edit it here, and move them to a
  # "blessed" repo like:
  #
  # brew install crane
  # crane copy <account>.dkr.ecr.us-west-2.amazonaws.com/cd/env_deploy@sha256:42a373721c2c26[...] \
  #   <account>.dkr.ecr.us-west-2.amazonaws.com/cd/env_deploy/blessed
  DEPLOY_IMAGE_DIGEST: "sha256:020c9d746d7281f8bd63710745ea2bc77a588b8001d0a5d898c42c7825b3680d"
  STOP_IMAGE_DIGEST: "sha256:617dbcc7148f677c91f8f531972bfe7c2e7e89d959db74a18c2d98390c0d229c"
  TEST_IMAGE_DIGEST: "sha256:67881c6fbd7caa2020c041dfdb730ba37112e5292231f1021ee7792d9b034357"
  GITDEPLOY_IMAGE_DIGEST: "sha256:9b79eedd4127db8b8834a64ead92ff0114f7b27350162751013bc58a55eb9015"
  GITTEST_IMAGE_DIGEST: "sha256:184373f9b221b51f045669b40032f08d3e05dad61e2ff10d17290be0fc476b08"
  NESSUS_URL: "https://44.230.151.136:8834"

.nessus_scan:
  timeout: 2h # Nessus scan runs long, takes awhile to finish
  stage: scan
  allow_failure: true
  rules:
    - if: $CI_SERVER_HOST != "gitlab.login.gov"
      when: never
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_COMMIT_BRANCH == $branch
  image:
    name: python:3.9.17
    entrypoint: [""]
  before_script:
    - curl -LO https://github.com/jqlang/jq/releases/download/jq-1.6/jq-linux64
    - chmod +x jq-linux64
    - mv jq-linux64 /usr/local/bin/jq
  script:
    # Find the scan id by searching through the names of all scans
    - >
      SCAN_ID=$(curl -k -s -X GET "$NESSUS_URL/scans" -H "X-ApiKeys: accessKey=$NESSUS_ACCESS_KEY; secretKey=$NESSUS_SECRET_KEY" | jq ".scans[] | select(.name | contains(\"$scan_env\")).id") &&
      if [ -z "$SCAN_ID" ]; then
          echo "No scan found containing the environment string: $scan_env";
          exit 0;
      fi
    # Launch the Nessus scan for the environment
    - 'curl -k -X POST "$NESSUS_URL/scans/$SCAN_ID/launch" -H "X-ApiKeys: accessKey=$NESSUS_ACCESS_KEY; secretKey=$NESSUS_SECRET_KEY"'
    # Wait on scan to complete before attempting the export to csv
    - >
      while [[ "$SCAN_STATUS" != "completed" ]]
      do
          sleep 300  # Wait for 5 minutes before checking again.
          SCAN_STATUS=$(curl -k -s -X GET "$NESSUS_URL/scans/$SCAN_ID" -H "X-ApiKeys: accessKey=$NESSUS_ACCESS_KEY; secretKey=$NESSUS_SECRET_KEY" | jq -r ".info.status")
          echo "Waiting on scan for $SCAN_ID to complete, current status $SCAN_STATUS"
      done
    # Initiate the export.
    - |
      FILE_ID=$(curl -s -k -X POST -H "X-ApiKeys: accessKey=$NESSUS_ACCESS_KEY; secretKey=$NESSUS_SECRET_KEY" -H 'Content-Type: application/json' -d '{"format": "csv"}' "$NESSUS_URL/scans/$SCAN_ID/export" | jq -r ".file")
      if [ -z "$FILE_ID" ]
      then
          echo "Failed to initiate the export. Exiting."
          exit 1
      fi
    # Check the status of the export.
    - |
      while [[ "$EXPORT_STATUS" != "ready" ]]
      do
          sleep 60  # Wait for 1 minute before checking again.
          EXPORT_STATUS=$(curl -s -k -X GET -H "X-ApiKeys: accessKey=$NESSUS_ACCESS_KEY; secretKey=$NESSUS_SECRET_KEY" "$NESSUS_URL/scans/$SCAN_ID/export/$FILE_ID/status" | jq -r ".status")
          if [[ "$EXPORT_STATUS" == "error" ]]
          then
              echo "Export encountered an error. Exiting."
              exit 1
          fi
      done
    # Download the exported file.
    - 'curl -s -k -X GET -H "X-ApiKeys: accessKey=$NESSUS_ACCESS_KEY; secretKey=$NESSUS_SECRET_KEY" "$NESSUS_URL/scans/$SCAN_ID/export/$FILE_ID/download" -o scan.csv'
    - python bin/lib/convert.py scan.csv
    # Grab the results of our Nessus scan without CIS Benchmark because that has a special format
    # Validate report schema locally using https://docs.gitlab.com/ee/development/integrations/secure.html#report
    - >
      jq --arg env "$scan_env" -r '
        [
          .[] |
          select(.Risk and .Risk != "PASSED" and .Risk != "FAILED" and .Risk != "WARNING") |
          {
            "id": ($env + " | " + (.Host | match("^[^-]+"; "g").string) + " | " + .Name),
            "vulnerability": .
          }
        ] | group_by(.id) | map(.[0].vulnerability) |
        if (length > 0) then
        {
          "version": "15.0.4",
          "scan": {
            "start_time": (now | strftime("%Y-%m-%dT%H:%M:%S")),
            "end_time": (now | strftime("%Y-%m-%dT%H:%M:%S")),
            "scanner": {
              "id": "Nessus",
              "name": "Nessus Scan",
              "version": "1.0.0",
              "vendor": {
                "name": "Tenable"
              }
            },
            "analyzer": {
              "id": "Nessus",
              "name": "Nessus Scan",
              "version": "1.0.0",
              "vendor": {
                "name": "Tenable"
              }
            },
            "scanned_resources": [
              {
                "method": "GET",
                "url": ("https://" + $env + ".identitysandbox.gov"),
                "type": "url"
              }
            ],
            "status": "success",
            "type": "dast"
          },
          "vulnerabilities": map({
            "id": ($env + " | " + (.Host | match("^[^-]+"; "g").string) + " | " + .Name),
            "name": ($env + " | " + (.Host | match("^[^-]+"; "g").string) + " | " + .Name),
            "description": .Description,
            "severity": (
              if .Risk == "CRITICAL" or .Risk == "Critical" then "Critical"
              elif .Risk == "HIGH" or .Risk == "High" then "High"
              elif .Risk == "MEDIUM" or .Risk == "Medium" then "Medium"
              elif .Risk == "LOW" or .Risk == "Low" then "Low"
              elif .Risk == "INFO" or .Risk == "Info" then "Info"
              elif .Risk == "None" or .Risk == "PASSED" then "Info"
              elif .Risk == "WARNING" or .Risk == "FAILED" then "Unknown"
              else "Unknown"
              end
            ),
            "solution": .Solution,
            "identifiers": [
              {
                "type": "cve",
                "name": ($env + " | " + (.Host | match("^[^-]+"; "g").string) + " | " + .Name),
                "url": (if .["See Also"] | test("^(https?|ftp)://.+") then .["See Also"] else "https://placeholder.text" end),
                "value": ($env + " | " + (.Host | match("^[^-]+"; "g").string) + " | " + .Name)
              }
            ],
            "links": [
              {
                "name": ($env + " - " + .Name),
                "url": (if .["See Also"] | test("^(https?|ftp)://.+") then .["See Also"] else "https://placeholder.text" end)
              }
            ],
            "location": {
              "hostname": .Host
            }
          })
        }
        else
        {
          "version": "15.0.4",
          "scan": {
            "start_time": (now | strftime("%Y-%m-%dT%H:%M:%S")),
            "end_time": (now | strftime("%Y-%m-%dT%H:%M:%S")),
            "scanner": {
              "id": "Nessus",
              "name": "Nessus Scan",
              "version": "1.0.0",
              "vendor": {
                "name": "Tenable"
              }
            },
            "analyzer": {
              "id": "Nessus",
              "name": "Nessus Scan",
              "version": "1.0.0",
              "vendor": {
                "name": "Tenable"
              }
            },
            "scanned_resources": [
              {
                "method": "GET",
                "url": ("https://" + $env + ".identitysandbox.gov"),
                "type": "url"
              }
            ],
            "status": "success",
            "type": "dast"
          },
          "vulnerabilities": []
        }
        end' < scan.json > gl-nessus-scanning-report.json
    # Grab the results of our Nessus scan CIS Benchmark and put into special format
    - >
      jq --arg env "$scan_env" -r '
        [
          .[] |
          select(.Risk == "FAILED" or .Risk == "WARNING") |
          {
            "id": ($env + " | " + (.Host | match("^[^-]+"; "g").string) + " | " + (.Description | split("\"")[1] | split(" - ")[0])),
            "vulnerability": .
          }
        ] | group_by(.id) | map(.[0].vulnerability) |
        if (length > 0) then
        {
          "version": "15.0.4",
          "scan": {
            "start_time": (now | strftime("%Y-%m-%dT%H:%M:%S")),
            "end_time": (now | strftime("%Y-%m-%dT%H:%M:%S")),
            "scanner": {
              "id": "Nessus",
              "name": "Nessus Scan",
              "version": "1.0.0",
              "vendor": {
                "name": "Tenable"
              }
            },
            "analyzer": {
              "id": "Nessus",
              "name": "Nessus Scan",
              "version": "1.0.0",
              "vendor": {
                "name": "Tenable"
              }
            },
            "scanned_resources": [
              {
                "method": "GET",
                "url": ("https://" + $env + ".identitysandbox.gov"),
                "type": "url"
              }
            ],
            "status": "success",
            "type": "dast"
          },
          "vulnerabilities": map({
            "id": ($env + " | " + (.Host | match("^[^-]+"; "g").string) + " | " + (.Description | split("\"")[1] | split(" - ")[0])),
            "name": ($env + " | " + (.Host | match("^[^-]+"; "g").string) + " | " + (.Description | split("\"")[1] | split(" - ")[0])),
            "description": .Description,
            "severity": (
              if .Risk == "CRITICAL" or .Risk == "Critical" then "Critical"
              elif .Risk == "HIGH" or .Risk == "High" then "High"
              elif .Risk == "MEDIUM" or .Risk == "Medium" then "Medium"
              elif .Risk == "LOW" or .Risk == "Low" then "Low"
              elif .Risk == "INFO" or .Risk == "Info" then "Info"
              elif .Risk == "None" or .Risk == "PASSED" then "Info"
              elif .Risk == "WARNING" or .Risk == "FAILED" then "Unknown"
              else "Unknown"
              end
            ),
            "solution": .Solution,
            "identifiers": [
              {
                "type": "cve",
                "name": ($env + " | " + (.Host | match("^[^-]+"; "g").string) + " | " + (.Description | split("\"")[1] | split(" - ")[0])),
                "url": (if .["See Also"] | test("^(https?|ftp)://.+") then .["See Also"] else "https://placeholder.text" end),
                "value": ($env + " | " + (.Host | match("^[^-]+"; "g").string) + " | " + (.Description | split("\"")[1] | split(" - ")[0]))
              }
            ],
            "links": [
              {
                "name": ($env + " | " + (.Host | match("^[^-]+"; "g").string) + " | " + (.Description | split("\"")[1] | split(" - ")[0])),
                "url": (if .["See Also"] | test("^(https?|ftp)://.+") then .["See Also"] else "https://placeholder.text" end)
              }
            ],
            "location": {
              "hostname": .Host
            }
          })
        }
        else
        {
          "version": "15.0.4",
          "scan": {
            "start_time": (now | strftime("%Y-%m-%dT%H:%M:%S")),
            "end_time": (now | strftime("%Y-%m-%dT%H:%M:%S")),
            "scanner": {
              "id": "Nessus",
              "name": "Nessus Scan",
              "version": "1.0.0",
              "vendor": {
                "name": "Tenable"
              }
            },
            "analyzer": {
              "id": "Nessus",
              "name": "Nessus Scan",
              "version": "1.0.0",
              "vendor": {
                "name": "Tenable"
              }
            },
            "scanned_resources": [
              {
                "method": "GET",
                "url": ("https://" + $env + ".identitysandbox.gov"),
                "type": "url"
              }
            ],
            "status": "success",
            "type": "dast"
          },
          "vulnerabilities": []
        }
        end' < scan.json > gl-cis-benchmark-scanning-report.json
    # Merge the reports together so there is one dast report
    - >
      jq -s '{
        version: .[0].version,
        scan: .[0].scan,
        vulnerabilities: ([.[0].vulnerabilities, .[1].vulnerabilities] | flatten)
      }' gl-cis-benchmark-scanning-report.json gl-nessus-scanning-report.json > nessus-report.json
  artifacts:
    paths:
      - nessus-report.json
    reports:
      dast: nessus-report.json

.container_scan_template:
  stage: scan
  interruptible: true
  allow_failure: true
  rules:
    # Make sure scans only run on prod, where images are built
    - if: $CI_SERVER_HOST != "gitlab.login.gov"
      when: never
    # Build on commits to default branch so we have something to scan for the security dashboard
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    # Build when the daily pipeline runs, but not for other scheduled pipelines.
    - if: '$CI_PIPELINE_SOURCE == "schedule" && $CI_CRON_SCHEDULE == "daily"'
    # Build when there are changes to the Dockerfile or versions.tf in a PR
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_PIPELINE_SOURCE == "external_pull_request_event"'
      changes:
        - dockerfiles/*
        - versions.tf
  tags:
    - build-pool
  image:
    name: $ECR_REGISTRY/ecr-public/aws-cli/aws-cli
    entrypoint: [""]
  before_script:
    - curl -LO https://github.com/jqlang/jq/releases/download/jq-1.6/jq-linux64
    - chmod +x jq-linux64
    - mv jq-linux64 /usr/local/bin/jq
  script:
    - >
      while true; do
        SCAN_STATUS=$(aws ecr describe-image-scan-findings --repository-name ${ecr_repo} --image-id imageTag=$CI_COMMIT_TAG --query 'imageScanStatus.status' --output text || true)
        if echo "$SCAN_STATUS" | grep -q "ACTIVE"; then
          echo "Scan Complete"
          break
        elif echo "$SCAN_STATUS" | grep -q "FAILED"; then
          echo "ECR scan failed"
          exit 1
        else
          echo "Waiting for ECR scan to complete"
          sleep 15
        fi
      done
    - SCAN_FINDINGS=$(aws ecr describe-image-scan-findings --repository-name ${ecr_repo} --image-id imageTag=$CI_COMMIT_TAG)
    - echo $SCAN_FINDINGS
    - >
      echo $SCAN_FINDINGS |
      jq -r 'if (.imageScanFindings.enhancedFindings | length > 0) then
      {
        "version": "15.0.4",
        "scan": {
          "start_time": (.imageScanFindings.imageScanCompletedAt | sub("\\.[0-9]+"; "") | strptime("%Y-%m-%dT%H:%M:%S%z") | strftime("%Y-%m-%dT%H:%M:%S")),
          "end_time": (.imageScanFindings.imageScanCompletedAt | sub("\\.[0-9]+"; "") | strptime("%Y-%m-%dT%H:%M:%S%z") | strftime("%Y-%m-%dT%H:%M:%S")),
          "scanner": {
            "id": "clair",
            "name": "Amazon ECR Image Scan",
            "version": "1.0.0",
            "vendor": {
              "name": "Amazon Web Services"
            }
          },
          "analyzer": {
            "id": "clair",
            "name": "Amazon ECR Image Scan",
            "version": "1.0.0",
            "vendor": {
              "name": "Amazon Web Services"
            }
          },
          "status": "success",
          "type": "container_scanning"
        },
        "vulnerabilities": [
          .imageScanFindings.enhancedFindings[] |
          {
            "id": .packageVulnerabilityDetails.vulnerabilityId,
            "name": .title,
            "description": .description,
            "severity": (if .severity == "HIGH" then "High"
                        elif .severity == "MEDIUM" then "Medium"
                        elif .severity == "LOW" then "Low"
                        elif .severity == "CRITICAL" then "Critical"
                        elif .severity == "INFORMATIONAL" then "Info"
                        elif .severity == "UNTRIAGED" then "Info"
                        else "Unknown" end),
            "solution": .remediation.recommendation.text,
            "identifiers": [
              {
                "type": "cve",
                "name": .packageVulnerabilityDetails.vulnerabilityId,
                "url": .packageVulnerabilityDetails.sourceUrl,
                "value": .packageVulnerabilityDetails.vulnerabilityId
              }
            ],
            "links": [
              {
                "name": .packageVulnerabilityDetails.vulnerabilityId,
                "url": .packageVulnerabilityDetails.sourceUrl
              }
            ],
            "location": {
              "dependency": {
                "package": {
                  "name": .packageVulnerabilityDetails.vulnerablePackages[0].name
                },
                "version": .packageVulnerabilityDetails.vulnerablePackages[0].version
              },
              "operating_system": .resources[0].details.awsEcrContainerImage.platform,
              "image": .resources[0].id
            }
          }
        ]
      }
      else
      {
        "version": "15.0.4",
        "scan": {
          "start_time": (now | strftime("%Y-%m-%dT%H:%M:%S")),
          "end_time": (now | strftime("%Y-%m-%dT%H:%M:%S")),
          "scanner": {
            "id": "clair",
            "name": "Amazon ECR Image Scan",
            "version": "1.0.0",
            "vendor": {
              "name": "Amazon Web Services"
            }
          },
          "analyzer": {
            "id": "clair",
            "name": "Amazon ECR Image Scan",
            "version": "1.0.0",
            "vendor": {
              "name": "Amazon Web Services"
            }
          },
          "status": "success",
          "type": "container_scanning"
        },
        "vulnerabilities": []
      }
      end' > gl-container-scanning-report.json
  artifacts:
    paths:
      - gl-container-scanning-report.json
    reports:
      container_scanning: gl-container-scanning-report.json

# TODO(LG-6069): Use an image from ECR
.build_template:
  stage: build
  interruptible: true
  tags:
    - build-pool
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  rules:
    # Don't build on gitstaging
    - if: $CI_SERVER_HOST == "gitlab.gitstaging.gitlab.login.gov"
      when: never
    # Build on commits to default branch so we have something to scan for the security dashboard
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    # Build when the daily pipeline runs, but not for other scheduled pipelines.
    - if: '$CI_PIPELINE_SOURCE == "schedule" && $CI_CRON_SCHEDULE == "daily"'
    # Build when there are changes to the Dockerfile or versions.tf in a PR
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_PIPELINE_SOURCE == "external_pull_request_event"'
      changes:
        - dockerfiles/*
        - versions.tf
  script:
    - mkdir -p /kaniko/.docker
    - |-
      KANIKOCFG="\"credsStore\":\"ecr-login\""
      if [ "x${http_proxy}" != "x" -o "x${https_proxy}" != "x" ]; then
        KANIKOCFG="${KANIKOCFG}, \"proxies\": { \"default\": { \"httpProxy\": \"${http_proxy}\", \"httpsProxy\": \"${https_proxy}\", \"noProxy\": \"${no_proxy}\"}}"
      fi
      KANIKOCFG="{ ${KANIKOCFG} }"
      echo "${KANIKOCFG}" > /kaniko/.docker/config.json
    - >-
      /kaniko/executor
      --context "${CI_PROJECT_DIR}"
      --dockerfile "${CI_PROJECT_DIR}/dockerfiles/${dockerfile}"
      --destination "${ECR_REGISTRY}/${ecr_repo}:latest"
      --destination "${ECR_REGISTRY}/${ecr_repo}:${CI_COMMIT_TAG}"
      --build-arg "http_proxy=${http_proxy}" --build-arg "https_proxy=${https_proxy}" --build-arg "no_proxy=${no_proxy}"

# Build images by providing a dockerfile (in dockerfiles/) and a destination ECR repo

build_gitlab_deploy_container:
  extends: .build_template
  variables:
    dockerfile: gitlab_deploy.Dockerfile
    ecr_repo: cd/gitlab_deploy

build_gitlab_test_container:
  extends: .build_template
  variables:
    dockerfile: gitlab_test.Dockerfile
    ecr_repo: cd/gitlab_test

build_env_deploy_container:
  extends: .build_template
  variables:
    dockerfile: env_deploy.Dockerfile
    ecr_repo: cd/env_deploy

build_env_stop_container:
  extends: .build_template
  variables:
    dockerfile: env_stop.Dockerfile
    ecr_repo: cd/env_stop

build_env_test_container:
  extends: .build_template
  variables:
    dockerfile: env_test.Dockerfile
    ecr_repo: cd/env_test

build_pivcac_ci_container:
  extends: .build_template
  variables:
    dockerfile: pivcac_ci.Dockerfile
    ecr_repo: pivcac/ci

build_dashboard_ci_container:
  extends: .build_template
  variables:
    dockerfile: dashboard_ci.Dockerfile
    ecr_repo: dashboard/ci

# Grab ECR scans and import into gitlab
scan_gitlab_deploy_container:
  extends: .container_scan_template
  variables:
    ecr_repo: cd/gitlab_deploy
  needs:
    - job: build_gitlab_deploy_container

scan_gitlab_test_container:
  extends: .container_scan_template
  variables:
    ecr_repo: cd/gitlab_test
  needs:
    - job: build_gitlab_test_container

scan_env_deploy_container:
  extends: .container_scan_template
  variables:
    ecr_repo: cd/env_deploy
  needs:
    - build_env_deploy_container

scan_env_stop_container:
  extends: .container_scan_template
  variables:
    ecr_repo: cd/env_stop
  needs:
    - build_env_stop_container

scan_env_test_container:
  extends: .container_scan_template
  variables:
    ecr_repo: cd/env_test
  needs:
    - build_env_test_container

scan_pivcac_ci_container:
  extends: .container_scan_template
  variables:
    ecr_repo: pivcac/ci
  needs:
    - build_pivcac_ci_container

# Run nessus scan after environment deploy and import to Security report dashboard
nessus_scan_dev_environment:
  extends: .nessus_scan
  variables:
    scan_env: dev
    branch: "main" # Needs to match the branch variable in env-scanners and be the default branch to avoid errors in Gitlab and import scan results correctly

nessus_scan_gitstaging_environment:
  extends: .nessus_scan
  variables:
    scan_env: "gitlab staging"
    branch: "main"

# IDP environments and their jobs
.include_idp_jobs_template:
  stage: deploy
  rules:
    - if: $CI_SERVER_HOST != "gitlab.login.gov"
      when: never
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_COMMIT_BRANCH == $branch
  trigger:
    include: .gitlab-ci-idp-env-jobs-template.yml

env-ursula:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: ursula
    branch: "stages/stable"

env-agnes:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: agnes
    branch: "stages/agnes"

env-joy:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: joy
    branch: "stages/joy"

env-dev:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: dev
    branch: "main"

env-henrydrich:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: henrydrich
    branch: "stages/henrydrich"

env-smgov:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: smgov
    branch: "stages/smgov"

env-akrito:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: akrito
    branch: "stages/akrito"

env-ryandbrown:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: ryandbrown
    branch: "stages/ryandbrown"

env-zmargolis:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: zmargolis
    branch: "stages/zmargolis"

env-jmdembe:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: jmdembe
    branch: "stages/stable"

env-solipet:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: solipet
    branch: "stages/stable"

env-scanners:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: scanners
    branch: "stages/stable"

env-aduth:
  extends: .include_idp_jobs_template
  variables:
    ENV_NAME: aduth
    branch: "stages/stable"

# deploy job template for gitlab envs
.deploy_gitlab_template:
  environment:
    name: $env
    url: $url
    action: start
  resource_group: $env
  rules:
    - if: $CI_SERVER_HOST != "gitlab.login.gov"
      when: never
    - if: $CI_PIPELINE_SOURCE != "push"
      when: never
    - if: $CI_COMMIT_BRANCH == $branch
  tags:
    - $env-env-runner
  image:
    # these are hardcoded to make this deploy process more secure.
    # If you want to update this image, you will need to edit it here, and in
    # s3://login-gov.secrets.<account>-us-west-2/<env>/gitlab_env_runner_allowed_images,
    # or s3://login-gov.secrets.<account>-us-west-2/common/gitlab_env_runner_allowed_images.
    # If you are doing development work, you can override them for your env.
    name: $ECR_REGISTRY/cd/gitlab_deploy/blessed@$GITDEPLOY_IMAGE_DIGEST
  stage: deploy
  variables:
    GIT_SUBMODULE_STRATEGY: normal
  artifacts:
    name: "$CI_ENVIRONMENT_NAME-$CI_COMMIT_SHA"
    paths:
      - terraform.plan
      - plan.txt
    expire_in: 1 year
    reports:
      terraform: plan.json
  script:
    - echo "Yay deploys!" ; exit 1

.recycle_runner_gitlab_template:
  extends: .deploy_gitlab_template
  environment:
    action: access
  variables:
    RECYCLE_ENV_RUNNERS_ONLY: "true"
  stage: post_deploy
  allow_failure: true

# test job template for gitlab envs
.test_gitlab_template:
  environment:
    name: $ENV_NAME
    url: $DOMAIN
    action: verify
  resource_group: $ENV_NAME
  rules:
    - if: $CI_SERVER_HOST != "gitlab.login.gov"
      when: never
    - if: $CI_PIPELINE_SOURCE != "push"
      when: never
    - if: $CI_COMMIT_BRANCH == $branch
  tags:
    - ${ENV_NAME}-env-runner
  image:
    # these are hardcoded to make this deploy process more secure.
    # If you want to update this image, you will need to edit it here, and in
    # s3://login-gov.secrets.<account>-us-west-2/<env>/gitlab_env_runner_allowed_images,
    # or s3://login-gov.secrets.<account>-us-west-2/common/gitlab_env_runner_allowed_images.
    name: $ECR_REGISTRY/cd/gitlab_test/blessed@$GITTEST_IMAGE_DIGEST
  stage: test
  script:
    - echo "Somebody set us up the deploy" ; exit 1
  artifacts:
    reports:
      junit: testlogs/*.xml
    when: always

# deploy jobs for gitstaging env here.
deploy_gitstaging:
  extends: .deploy_gitlab_template
  variables:
    env: gitstaging
    url: https://gitlab.gitstaging.gitlab.login.gov/
    branch: main

recycle_runner_gitstaging:
  extends: .recycle_runner_gitlab_template
  variables:
    env: gitstaging
    url: https://gitlab.gitstaging.gitlab.login.gov/
    branch: main

.run_unallowed_image_template:
  image:
    name: $ECR_REGISTRY/ecr-public/docker/library/alpine:latest
  environment:
    action: verify
    url: https://${DOMAIN}/
    name: ${ENV_NAME}
  tags:
    - ${ENV_NAME}-env-runner
  stage: test
  allow_failure: true
  script:
    - touch unallowed.txt
  artifacts:
    paths:
      - "*.txt"
  rules:
    - if: $CI_SERVER_HOST != "gitlab.login.gov"
      when: never
    - if: $CI_COMMIT_BRANCH == $TRIGGER_BRANCH && $CI_PIPELINE_SOURCE == "push"

run_unallowed_image_gitstaging:
  extends: .run_unallowed_image_template
  variables:
    ENV_NAME: gitstaging
    DOMAIN: gitlab.gitstaging.gitlab.login.gov
    TRIGGER_BRANCH: main

.test_unallowed_image_template:
  environment:
    action: verify
    url: https://${DOMAIN}/
    name: ${ENV_NAME}
  tags:
    - test-pool
  stage: test
  script:
    - test ! -f unallowed.txt
  rules:
    - if: $CI_SERVER_HOST != "gitlab.login.gov"
      when: never
    - if: $CI_COMMIT_BRANCH == $TRIGGER_BRANCH && $CI_PIPELINE_SOURCE == "push"

test_unallowed_image_gitstaging:
  extends: .test_unallowed_image_template
  variables:
    ENV_NAME: gitstaging
    DOMAIN: gitlab.gitstaging.gitlab.login.gov
    TRIGGER_BRANCH: main
  needs:
    - run_unallowed_image_gitstaging

test_gitstaging:
  extends: .test_gitlab_template
  variables:
    ENV_NAME: gitstaging
    DOMAIN: gitlab.gitstaging.gitlab.login.gov
    branch: main

deploygitlabproduction_trigger:
  stage: gitlabproduction_deploy
  resource_group: gitlabproduction
  needs:
    - job: test_gitstaging
      optional: true
  when: manual
  environment:
    name: gitlabproduction
    url: https://gitlab.login.gov/
  image:
    name: $ECR_REGISTRY/ecr-public/docker/library/alpine
  script:
    - apk --no-cache add curl jq
    - curl --request POST --form token="$GITSTAGING_PIPELINE_TRIGGER_TOKEN" --form ref=main --form "variables[ENV_NAME]=production" "https://gitlab.gitstaging.gitlab.login.gov/api/v4/projects/$GITSTAGING_DEPLOY_PROJECT_ID/trigger/pipeline" > /tmp/curl.out
    - if [ "$(jq -r .status < /tmp/curl.out)" != "created" ] ; then echo "pipeline trigger failed" ; exit 1 ; fi
  rules:
    - if: $CI_SERVER_HOST != "gitlab.login.gov"
      when: never
    - if: $CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"

# deploy gitlab production env here.
# This only runs on gitstaging, and is triggered by the API call in deploygitlabproduction_trigger
deploy_production:
  extends: .deploy_gitlab_template
  variables:
    env: production
    url: https://gitlab.login.gov/
  # Override rules, since this will be run in a triggered pipeline only
  rules:
    - if: $CI_PIPELINE_SOURCE != "trigger"
      when: never
    - if: $CI_SERVER_HOST == "gitlab.gitstaging.gitlab.login.gov"

# recycle gitlab production env runner here.
# This only runs on gitstaging, and is triggered by the API call in deploygitlabproduction_trigger
recycle_runner_production:
  extends: .recycle_runner_gitlab_template
  variables:
    env: production
    url: https://gitlab.login.gov/
  # Override rules, since this will be run in a triggered pipeline only
  rules:
    - if: $CI_PIPELINE_SOURCE != "trigger"
      when: never
    - if: $CI_SERVER_HOST == "gitlab.gitstaging.gitlab.login.gov"

# test gitlab production env here.
# This only runs on gitstaging, and is triggered by the API call in deploygitlabproduction_trigger
test_production:
  extends: .test_gitlab_template
  variables:
    ENV_NAME: production
    DOMAIN: gitlab.login.gov
  # Override rules, since this will be run in a triggered pipeline only
  rules:
    - if: $CI_PIPELINE_SOURCE != "trigger"
      when: never
    - if: $CI_SERVER_HOST == "gitlab.gitstaging.gitlab.login.gov"

# deploy jobs for gitlabcharlie env here.
deploy_charlie:
  extends: .deploy_gitlab_template
  variables:
    env: charlie
    url: https://gitlab.charlie.gitlab.identitysandbox.gov/
    branch: "stages/gitlabcharlie"

recycle_runner_charlie:
  extends: .recycle_runner_gitlab_template
  variables:
    env: charlie
    url: https://gitlab.identitysandbox.gov/
    branch: "stages/gitlabcharlie"

test_charlie:
  extends: .test_gitlab_template
  variables:
    ENV_NAME: charlie
    DOMAIN: gitlab.charlie.gitlab.login.gov
    branch: "stages/gitlabcharlie"

run_unallowed_image_charlie:
  extends: .run_unallowed_image_template
  variables:
    ENV_NAME: charlie
    DOMAIN: gitlab.charlie.gitlab.login.gov
    TRIGGER_BRANCH: stages/gitlabcharlie

test_unallowed_image_charlie:
  extends: .test_unallowed_image_template
  variables:
    ENV_NAME: charlie
    TRIGGER_BRANCH: stages/gitlabcharlie
    DOMAIN: gitlab.charlie.gitlab.login.gov
  needs:
    - run_unallowed_image_charlie

# deploy jobs for gitlabbravo env here.
deploy_bravo:
  extends: .deploy_gitlab_template
  variables:
    env: bravo
    url: https://gitlab.identitysandbox.gov/
    branch: "stages/gitlabbravo"

recycle_runner_bravo:
  extends: .recycle_runner_gitlab_template
  variables:
    env: bravo
    url: https://gitlab.identitysandbox.gov/
    branch: "stages/gitlabbravo"

test_bravo:
  extends: .test_gitlab_template
  variables:
    ENV_NAME: bravo
    DOMAIN: gitlab.identitysandbox.gov
    branch: "stages/gitlabbravo"

run_unallowed_image_bravo:
  extends: .run_unallowed_image_template
  variables:
    ENV_NAME: bravo
    DOMAIN: gitlab.identitysandbox.gov
    TRIGGER_BRANCH: stages/gitlabbravo

test_unallowed_image_bravo:
  extends: .test_unallowed_image_template
  variables:
    ENV_NAME: bravo
    DOMAIN: gitlab.identitysandbox.gov
    TRIGGER_BRANCH: stages/gitlabbravo
  needs:
    - run_unallowed_image_bravo

# deploy jobs for gitlabalpha env here.
deploy_alpha:
  extends: .deploy_gitlab_template
  variables:
    env: alpha
    url: https://gitlab.alpha.gitlab.identitysandbox.gov
    branch: "stages/gitlabalpha"

test_alpha:
  extends: .test_gitlab_template
  variables:
    ENV_NAME: alpha
    DOMAIN: gitlab.alpha.gitlab.identitysandbox.gov
    branch: "stages/gitlabalpha"

recycle_runner_alpha:
  extends: .recycle_runner_gitlab_template
  variables:
    env: alpha
    url: https://gitlab.alpha.gitlab.identitysandbox.gov/
    branch: "stages/gitlabalpha"

run_unallowed_image_alpha:
  extends: .run_unallowed_image_template
  variables:
    ENV_NAME: alpha
    DOMAIN: gitlab.alpha.gitlab.login.gov
    TRIGGER_BRANCH: stages/gitlabalpha

test_unallowed_image_alpha:
  extends: .test_unallowed_image_template
  variables:
    ENV_NAME: alpha
    DOMAIN: gitlab.gitstaging.gitlab.login.gov
    TRIGGER_BRANCH: stages/gitlabalpha
  needs:
    - run_unallowed_image_alpha

test_images_exist:
  stage: pre_deploy_test
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_PIPELINE_SOURCE == "external_pull_request_event"'
      changes:
        - .gitlab-ci.yml
  image:
    name: $ECR_REGISTRY/ecr-public/aws-cli/aws-cli
    entrypoint: [""]
  script:
    - aws ecr describe-images --repository-name cd/env_deploy/blessed --image-ids imageDigest=$DEPLOY_IMAGE_DIGEST
    - aws ecr describe-images --repository-name cd/env_stop/blessed --image-ids imageDigest=$STOP_IMAGE_DIGEST
    - aws ecr describe-images --repository-name cd/env_test/blessed --image-ids imageDigest=$TEST_IMAGE_DIGEST
    - aws ecr describe-images --repository-name cd/gitlab_deploy/blessed --image-ids imageDigest=$GITDEPLOY_IMAGE_DIGEST
    - aws ecr describe-images --repository-name cd/gitlab_test/blessed --image-ids imageDigest=$GITTEST_IMAGE_DIGEST

include:
  - local: .gitlab-ci-rules.yml
  - local: kitchen/cookbooks/identity-gitlab/.gitlab-ci.yml
  - local: terraform/.gitlab-ci.yml
  - local: cloudlib/.gitlab-ci.yml
  - local: bin/users/.gitlab-ci.yml
  - template: Security/SAST-IaC.gitlab-ci.yml
  - template: Security/SAST.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
