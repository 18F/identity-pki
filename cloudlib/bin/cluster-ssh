#!/usr/bin/env ruby

require 'optparse'
require 'rbconfig'

require 'bundler/setup'
require_relative '../lib/cloudlib'
require 'subprocess'


def log
  Cloudlib.cli_log
end

def cssh_command
  if RbConfig::CONFIG.fetch('host_os').start_with?('darwin')
    if ENV['TERM_PROGRAM'] != 'Apple_Terminal'
      log.warn('Terminal program is not Apple Terminal.app')
      log.warn('Probably things will be weird')
      log.warn("$TERM_PROGRAM: " + ENV['TERM_PROGRAM'].inspect)
    end
    'csshX'
  else
    'cssh'
  end
end

def clusterssh(instances)
  ssh_cmd = File.absolute_path(File.join(File.dirname(__FILE__), 'ssh-instance'))

  cmd = [
    cssh_command,
    '--ssh', ssh_cmd,
  ]

  # pass through AWS_PROFILE since csshX doesn't pass through env variables
  if ENV['AWS_PROFILE']
    cmd += ['--ssh_args', "--aws-profile #{ENV['AWS_PROFILE']}"]
  end

  cmd += ['--'] + instances.map(&:instance_id)

  log.info("+ " + cmd.join(' '))
  Subprocess.check_call(cmd)
end

def find_instances_for_env(env)
  log.info("Listing running instances for #{env.inspect} environment")

  cl = Cloudlib::EC2.new(env: env)
  instances = cl.instances_in_vpc(states: ['running'])

  log.info("Found instances: " + instances.map(&:instance_id).join(' '))

  log.info("Hosts: \n  - " + instances.map {|i| cl.instance_label(i) }.join("\n  - "))

  instances
end

def main(args)
  find_opts = {states: ['running']}

  basename = File.basename($0)

  optparse = OptionParser.new do |opts|
    opts.banner = <<-EOM
usage: #{File.basename($0)} [OPTIONS]

Open interactive SSH windows to all instances according to ls-servers like
filters using cssh/csshX (must be apt/brew installed). The ssh connections are
established using ssh-instance.

At least one filter option (-e, -n, etc.) must be specified. The filters
operate similarly to ls-servers.

Examples:

    # SSH to servers in QA VPC
    #{basename} -e qa

    # SSH to jumphost servers in all environments
    #{basename} -n '*jumphost*'

    # SSH to all dev ASG IDP servers
    #{basename} -e dev -n 'asg-*-idp'

Options:
    EOM

    opts.on('-h', '--help', 'Print this message') do
      STDERR.puts opts
      exit
    end

    opts.on('-e', '--env ENVIRONMENT',
            'Filter servers by ENVIRONMENT') do |val|
      find_opts[:env] = val
    end

    opts.on('-n', '--name GLOB', 'Find servers Name matching GLOB') do |val|
      find_opts[:name_glob] = val
    end
  end

  args = optparse.parse(args)

  # print error if we have no find_opts other than :states
  if find_opts.reject{|k, v| k == :states}.empty?
    STDERR.puts optparse
    STDERR.puts "\n#{basename}: must pass at least one filter (-e, -n, etc.)"
    exit 1
  end

  instances = Cloudlib::EC2.cli_find_servers(find_opts)

  # TODO: add ability to pass through options to ssh-instance, or prepopulate
  # the SSH command line and don't use ssh-instance
  clusterssh(instances)
end

if $0 == __FILE__
  main(ARGV)
end
