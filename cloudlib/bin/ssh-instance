#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'

Dir.chdir(File.dirname(__FILE__)) { require 'bundler/setup' }

require_relative '../lib/cloudlib'

def log
  Cloudlib.cli_log
end

def ssh_instance(instance:, ssh_cmdline_opts:)
  log.info("SSH to #{Cloudlib::EC2.instance_label(instance)}")
  single = Cloudlib::SSH::Single.new(instance: instance)
  single.ssh_exec(ssh_cmdline_opts: ssh_cmdline_opts)
end

def get_instance_by_id(instance_id)
  log.debug("Looking up instance ID #{instance_id.inspect}")
  Cloudlib::EC2.new.lookup_instance_by_id(instance_id)
end

def get_instance_by_name(name_tag, states: ['running'], pick_strategy: nil)
  filters = [
    {name: 'tag:Name', values: [name_tag]},
    {name: 'instance-state-name', values: states},
  ]

  # Interactively prompt by default iff we're connected to a TTY.
  if pick_strategy.nil?
    if STDIN.tty? && STDERR.tty?
      pick_strategy = :prompt
    else
      pick_strategy = :unique
    end
  end

  case pick_strategy
  when :random
    log.debug("Looking up random instance named #{name_tag.inspect}")
    Cloudlib::EC2.new.get_random_thing(:instances, filters)
  when :oldest
    log.debug("Looking up oldest instance named #{name_tag.inspect}")
    instances = Cloudlib::EC2.new.list_things(:instances, filters)
    instances.sort_by(&:launch_time).first
  when :newest
    log.debug("Looking up newest instance named #{name_tag.inspect}")
    instances = Cloudlib::EC2.new.list_things(:instances, filters)
    instances.sort_by(&:launch_time).fetch(-1)
  when :unique
    log.debug("Looking up instance named #{name_tag.inspect}")
    Cloudlib::EC2.new.get_unique_thing(:instances, filters)
  when :prompt
    log.debug("Looking up instances named #{name_tag.inspect}")
    Cloudlib::EC2.new.find_instance_interactive(
      filters: filters,
      prompt_text: "Found multiple instances named #{name_tag.inspect}:"
    )
  else
    raise ArgumentError.new("Unknown pick_strategy: #{pick_strategy.inspect}")
  end
end

def main(args)
  options = {pick_strategy: nil}
  cl_ssh_options = {}

  basename = File.basename($0)

  optparse = OptionParser.new do |opts|
    opts.banner = <<-EOM
usage: #{basename} [OPTIONS] [USER@]HOST [COMMAND]

SSH to an individual EC2 instance. HOST may be specified by EC2 Instance ID or
by EC2 instance "Name" tag.

If USER is not specified, it defaults to $GSA_USERNAME.

When there are multiple instances found with the same name tag (like
asg-dev-jumphost), an interactive prompt will appear by default. There are
several options to choose systematically: --newest, --oldest, --any.

Examples:

    # SSH to a specific instance
    #{basename} i-abcd1234

    # SSH with a username
    #{basename} ubuntu@i-abcd1234

    # SSH to an interactively selected auto scaled IDP instance by name tag
    #{basename} asg-dev-idp

    # Quietly SSH to a randomly selected matching es server, run hostname
    #{basename} -1 -q login-es*-qa hostname -f

    # SSH, forwarding a local port to a remote destination
    #{basename} -L 5601:localhost:5601 i-abcd1234

    # SSH to an interactively selected server in dev
    #{basename} -P 'asg-dev-*'

Options:
    EOM

    opts.on('-h', '--help', 'Display this message') do
      STDERR.puts opts
      exit
    end

    opts.on('-v', '--verbose', 'Be more verbose') do
      cl_ssh_options[:verbose] = true
      Cloudlib.log_level -= 1 if Cloudlib.log_level > 0
    end

    opts.on('-q', '--quiet', 'Be quieter (can pass multiple times)') do
      cl_ssh_options[:verbose] = false
      cl_ssh_options[:quiet] = true
      Cloudlib.log_level += 1
    end

    opts.on('-l', '--login USER', 'SSH login username') do |val|
      cl_ssh_options[:username] = val
    end

    opts.on('--jumphost-login USER', 'Jumphost SSH login username') do |val|
      cl_ssh_options[:jumphost_username] = val
    end

    opts.on('-1', '--any', 'SSH to random server matching name') do
      options[:pick_strategy] = :random
    end

    opts.on('--newest', 'Pick server with most recent boot time') do
      options[:pick_strategy] = :newest
    end

    opts.on('--oldest', 'Pick server with oldest boot time') do
      options[:pick_strategy] = :oldest
    end

    opts.on('-P', '--prompt', 'Pick server interactively if ambiguous') do
      options[:pick_strategy] = :prompt
    end

    opts.on('-j', '--[no-]jumphost', 'Whether to use a jumphost') do |val|
      cl_ssh_options[:use_jumphost] = val
    end

    opts.on('--jumphost-id INSTANCE',
            'Specify instance ID of jumphost') do |val|
      cl_ssh_options[:jumphost_instance_id] = val
    end

    opts.on('-L', '--local-forward OPT',
            'forward local ports over SSH (can pass multiple times)') do |val|
      cl_ssh_options[:local_forwards] ||= []
      cl_ssh_options[:local_forwards] += ['-L', val]
    end

    opts.on('-D', '--socks-forward OPT',
            'listen on OPT as a SOCKS proxy, forwarding to remote') do |val|
      cl_ssh_options[:ssh_opts] ||= []
      cl_ssh_options[:ssh_opts] += ['-D', val]
    end

    opts.on('-o', '--ssh-opt OPT',
            'Set SSH option (may be passed multiple times)') do |val|
      cl_ssh_options[:ssh_opts] ||= []
      cl_ssh_options[:ssh_opts] += ['-o', val]
    end

    opts.on('-I', '--pkcs11 LIB',
            'Use LIB for SSH with a PCKS#11 library') do |val|
      cl_ssh_options[:ssh_opts] ||= []
      cl_ssh_options[:ssh_opts] += ['-I', val]
    end

    opts.on('--no-pkcs11', 'Disable use of PKCS#11 library') do
      cl_ssh_options[:pkcs11_lib] = false
    end

    opts.on('-x', 'Ignored for use as SSH wrapper') do
    end

    opts.on('--aws-profile PROFILE', 'Set AWS_PROFILE env variable') do |val|
      ENV['AWS_PROFILE'] = val
      log.debug("AWS_PROFILE=#{val.inspect}")
    end
  end

  host_and_cmd = optparse.order(args)

  if host_and_cmd.empty?
    STDERR.puts optparse
    exit 1
  end

  host_spec = host_and_cmd.shift
  if !host_and_cmd.empty?
    cl_ssh_options[:command] = host_and_cmd
  end

  if host_spec.include?('@')
    cl_ssh_options[:username], host_spec = host_spec.split('@', 2)
  end

  host_spec = host_spec.strip

  if host_spec =~ /\Ai-[a-f0-9]+\z/
    instance = get_instance_by_id(host_spec)
  else
    instance = get_instance_by_name(
      host_spec, pick_strategy: options.fetch(:pick_strategy)
    )
  end

  if !host_and_cmd.empty?
    cl_ssh_options[:command] = host_and_cmd
  end

  ssh_instance(instance: instance, ssh_cmdline_opts: cl_ssh_options)
end

if __FILE__ == $0
  main(ARGV)
end
