#!/usr/bin/env ruby

require 'optparse'

require 'bundler/setup'
require_relative '../lib/cloudlib'

require 'terminal-table'

# Everything except terminated
DefaultStatesFilter = %w{
  pending
  running
  rebooting
  stopping
  stopped
  shutting-down
}.map(&:freeze).freeze

def log
  Cloudlib.cli_log
end

# Take the output of data_for_instances and join it with an array of
# TargetHealthDescription objects, so that each instance gets its health added
# as a member. Instances not listed by describe_target_health are excluded
def collate_instances_with_target(instance_data, target_data)
  health_by_instance = Hash[(target_data).map { |t| [t.target.id,
                                                     t.target_health.state] }]
  output_header = instance_data[:header].push('health')
  output_rows = []
  instance_data[:rows].each do |instance_row|
    instance_id = instance_row[0]
    if health_by_instance.key?(instance_id)
      output_rows.push(instance_row.push(health_by_instance[instance_id]))
    end
  end
  return {
    header: output_header,
    rows: output_rows
  }
end

def print_data_batch(data, skip_header: false)
  puts data.fetch(:header).join("\t") unless skip_header
  data.fetch(:rows).each do |row|
    puts row.join("\t")
  end
end

def print_data_table(data, skip_header: false)
  if skip_header
    table = Terminal::Table.new(rows: data.fetch(:rows))
  else
    table = Terminal::Table.new(headings: data.fetch(:header),
                                rows: data.fetch(:rows))
  end
  puts table
end

def main(args)

  options = {}
  find_opts = {states: DefaultStatesFilter}
  data_for_instances_opts = {}

  basename = File.basename($0)

  optparse = OptionParser.new do |opts|
    opts.banner = <<-EOM
usage: #{basename} [OPTIONS]

List servers by filters.

For example:

  # list all servers in QA
  #{basename} -e qa

  # list all non-asg servers in dev
  #{basename} -n 'login-*-dev'

  # list all dev ASG IDP servers
  #{basename} -n 'asg-dev-idp'

  # list all es servers in dev
  #{basename} -n 'login-es*-dev'

  # list all idp and worker servers in dev
  #{basename} -e dev -n '*-idp' -n '*-worker'

  # list all idp servers in dev, with target health status
  #{basename} -e dev -r idp

Options:
    EOM

    opts.on('-h', '--help', 'Display this message') do
      STDERR.puts opts
      exit
    end

    opts.on('-v', '--verbose', 'Be more verbose') do
      Cloudlib.log_level -= 1 if Cloudlib.log_level > 0
    end

    opts.on('-q', '--quiet', 'Be quieter (can pass multiple times)') do
      Cloudlib.log_level += 1
    end

    opts.on('-e', '--env ENVIRONMENT',
            'List all servers in ENVIRONMENT') do |val|
      find_opts[:env] = val
    end

    opts.on('-l', '--long', 'Use long header listing') do
      data_for_instances_opts[:long_headers] = true
    end

    opts.on('-r', '--health_role ROLE',
            'Include health data for autoscaled servers of type ROLE') do |val|
      options[:health_role] = val
    end

    opts.on('-n', '--name GLOB', 'Find servers Name matching GLOB') do |val|
      find_opts[:name_globs] ||= []
      find_opts[:name_globs] << val
    end

    opts.on('-s', '--states STATES', 'Comma/space sep. list of states') do |val|
      find_opts[:states] = val.split(/[\s,]/)
    end

    opts.on('-b', '--batch', 'Use machine friendly tab output') do
      options[:batch] = true
    end

    opts.on('-H', '--no-header', 'Skip header output') do
      options[:skip_header] = true
    end

    opts.on('-f', '--filter FILTER', 'Not yet implemented') do |val|
      raise NotImplementedError.new
    end
  end

  optparse.parse!

  # print error if health_role used incorrectly
  if options[:health_role]
    if find_opts[:env].nil? || find_opts[:name_globs]
      STDERR.puts optparse
      STDERR.puts ("\n#{basename}: -r and --health_role require specifying an " +
                   "environment and no name filter.")
      exit 1
    end
  end

  # print error if we have no find_opts other than :states
  if find_opts.reject{|k, v| k == :states}.empty?
    STDERR.puts optparse
    STDERR.puts "\n#{basename}: must pass at least one filter (-e, -n, etc.)"
    exit 1
  end

  instances = Cloudlib::EC2.cli_find_servers(find_opts)

  instance_data = Cloudlib::ListServers.data_for_instances(
    instances, **data_for_instances_opts
  )

  if options[:health_role]
    target_data = Cloudlib::ElasticLoadBalancingV2.new.find_target_health_data(find_opts[:env], options[:health_role])
    data = collate_instances_with_target(instance_data, target_data)
  else
    # If health_role is not specified, behave exactly as before.
    data = instance_data
  end

  if options[:batch]
    print_data_batch(data, skip_header: options[:skip_header])
  else
    print_data_table(data, skip_header: options[:skip_header])
  end
end

if __FILE__ == $0
  main(ARGV)
end
