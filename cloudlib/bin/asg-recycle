#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'

Dir.chdir(File.dirname(__FILE__)) { require 'bundler/setup' }
require_relative '../lib/cloudlib'

def log
  Cloudlib.cli_log
end

def main
  recycle_opts = {}
  skip_migration = false
  skip_idpxtra = false
  skip_worker = false

  basename = File.basename($0)

  optparse = OptionParser.new do |opts|
    opts.banner = <<-EOM
usage: #{basename} [OPTIONS] ENVIRONMENT ROLE [RETURN_TO_COUNT]

Create AWS ASG scheduled actions to recycle instances in an ASG by spinning up
twice as many instances and then spinning back down to the usual number.

By default, spins up 2x instances immediately and spins down to the normal
number after 2x the ASG's health check grace period. The grace period on an ASG
defaults to 5 minutes, so if it hasn't been changed, we will spin down to the
normal number after 10 minutes.

If the idp role is specified, a migration instance will be started.
5 minutes (default) later the idp desired instance size will be set to 2x, and
finally returned to original count after the default spindown of 15 minutes.
To disable spooling in a migration instance use the -s / --skip-migration flag.

Use -i/--immediate to configure the desired number of instances set immediately
Use -t/--return-to to configure the desired number of instances after spin down

It is dangerous to spin down instances before the grace period has elapsed
because the ASG ignores health check results during the grace period and could
spin down healthy instances with no replacements available. To ensure safety,
use ASG lifecycle hooks to ensure that instances don't enter the InService
state before they are finished bootstrapping. With lifecycle hooks in place,
the health check grace period is 0. We default to a spindown delay of 15
minutes in this case.

For example:

    # recycle instances in the "int-idp" ASG by doubling and then returning
    #{basename} int idp

    # (DESTRUCTIVE) immediately set desired count to 0, then set it to 2 after
    # two minutes
    #{basename} --immediate 0 --return-to 2 --delay 120 dev app

    # Recycle idp instances, first scaling out a migration instances, waiting the
    # default 5 minutes, then starting normal idp recycling
    #{basename} int idp

    # Recycle idp instances starting immediately without starting a migration
    # instance
    #{basename} --skip-migration int idp

    # set to 2 instances immediately, then return to 1 without starting a
    # migration instance first
    #{basename} -i 2 -t 1 -n int idp

    # Recycle everything except persistent and utility instances and with
    # a migration instance spun up prior to idp spin up
    #{basename} int ALL

    EOM

    opts.on('-h', '--help', 'Display this message') do
      STDERR.puts opts
      exit
    end

    opts.on('-v', '--verbose', 'Be more verbose') do
      Cloudlib.log_level -= 1 if Cloudlib.log_level > 0
    end

    opts.on('-q', '--quiet', 'Be quieter (can pass multiple times)') do
      Cloudlib.log_level += 1
    end

    opts.on('--delay SEC', 'Wait before scheduled spindown') do |val|
      recycle_opts[:spindown_delay] = Integer(val)
    end

    opts.on('-i', '--immediate SIZE',
            'Number of instances to spin up') do |val|
      recycle_opts[:new_size] = Integer(val)
    end

    opts.on('-t', '--return-to SIZE',
            'Target number of instances after spin down') do |val|
      recycle_opts[:return_to_size] = Integer(val)
    end

    opts.on('-s', '--skip-migration',
            'Do not run migration instance before starting IdP recycle') do
      skip_migration = true
    end

    opts.on('-W', '--skip-worker', 'Do not include Worker in IDP role recycle') do
      skip_worker = true
    end

    opts.on('-X', '--skip-idpxtra', 'Do not include IDPXtra in IDP role recycle') do
      skip_idpxtra = true
    end

    opts.on('--delay-for-migration SEC',
            'Wait after migration start to spin up IdPs (Default: 300)') do |val|
      recycle_opts[:spinup_delay] = Integer(val)
    end
  end

  args = optparse.parse!

  case args.length
  when 2
    env, role = args
  when 3
    env, role, return_to_size = args
    recycle_opts[:return_to_size] = Integer(return_to_size)
  else
    STDERR.puts optparse
    exit 1
  end

  as = Cloudlib::AutoScaling.new

  if role == 'ALL'
    # Note - pre-migration handled inside recycle_all_asgs_in_env if set
    as.recycle_all_asgs_in_env(env,
                               recycle_opts: recycle_opts,
                               skip_migration: skip_migration)
  else
    asg_name = "#{env}-#{role}"

    # Manage pre-migration
    if !skip_migration && (role == 'idp' || role == 'idpxtra' || role == 'worker')
      puts as.pastel.bold.yellow("Launching migration instance prior to #{role} spin up")
      as.start_recycle("#{env}-migration",
                       new_size: 1,
                       return_to_size: 0,
                       spindown_delay: recycle_opts[:spindown_delay])

      # Set a spinup delay if not explicity set
      if recycle_opts[:spinup_delay].nil?
        recycle_opts[:spinup_delay] = as.default_migration_delay
      end
    end

    as.start_recycle(asg_name, **recycle_opts)

    if !skip_idpxtra && role == 'idp'
      puts as.pastel.bold.yellow('Recycling idpxtra instance in parallel with idp')
      as.start_recycle("#{env}-idpxtra", skip_zero: true, **recycle_opts)
    end

    if !skip_worker && role == 'idp'
      puts as.pastel.bold.yellow('Recycling worker instance in parallel with idp')
      as.start_recycle("#{env}-worker", skip_zero: true, **recycle_opts)
    end

    puts as.pastel.bold.blue('Done! Watch #login-events / #login-otherevents for abandoned/failed launches')
  end
end

if __FILE__ == $0
  begin
    main
  rescue TTY::Reader::InputInterrupt
    STDERR.puts 'OK, aborted'
    exit 2
  end
end
