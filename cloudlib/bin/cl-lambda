#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'

Dir.chdir(File.dirname(__FILE__)) do
  require 'bundler/setup'
end
require_relative '../lib/cloudlib'

def log
  Cloudlib.cli_log
end

def main
  options = {}

  basename = File.basename($0)

  optparse = OptionParser.new do |opts|
    opts.banner = <<-EOM
usage: #{basename} [options] COMMAND

COMMAND may be:
    list              List known lambdas in current repo
    init              Initialize configuration and set up symlinks
    info NAME         Show information about the NAME lambda
    deploy NAME ENV   Deploy current rev of NAME lambda to the ENV environment

Options:
    EOM

    opts.on('-h', '--help', 'Display this message') do
      STDERR.puts opts
      exit
    end

    opts.on('-v', '--verbose', 'Be more verbose') do
      Cloudlib.log_level -= 1 if Cloudlib.log_level > 0
    end

    opts.on('-q', '--quiet', 'Be quieter (can pass multiple times)') do
      Cloudlib.log_level += 1
    end
  end

  args = optparse.parse!

  if args.empty?
    STDERR.puts optparse
    exit 1
  end

  begin
    cl = Cloudlib::Lambda.new

    command = args.shift
    case command
    when 'init'
      cl.cmd_init(args: args, **options)
    when 'list'
      cl.cmd_list(args: args, **options)
    when 'deploy'
      cl.cmd_deploy(args: args, **options)
    when 'info'
      cl.cmd_info(args: args, **options)
    else
      raise Cloudlib::CLIUsageError.new(
        "Error: unknown command #{command.inspect}"
      )
    end

  rescue Cloudlib::CLIUsageError => err
    STDERR.puts optparse
    STDERR.puts "\nError: #{err.message}" if err.message != err.class.name
    exit 1
  rescue Cloudlib::CLIError => err
    STDERR.puts "Error: #{err.message}"
    exit 2
  end
end

if __FILE__ == $0
  main
end
