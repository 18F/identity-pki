#!/bin/bash

#### Grab AMI data and build a PR with it! ####

set -euo pipefail

. "$(dirname "$0")/lib/common.sh"

usage() {
  cat >&2 << EOM

Usage: ${0} [-uospbr]

Flags (will run all if no flags specified):
  -l : Show AMI data output table only
  -u : Update ami_id values in terraform/app/variables.tf
  -o : Create ami/DATE branch + open a PR with ami_id changes
  -b : Only update the base AMI IDs
  -r : Only update the rails AMI IDs
  -h : Detailed help

Manually set AMIs for specific account and/or type:
  --sb=<AMI_ID> | --sandbox-base=<AMI_ID>
  --sr=<AMI_ID> | --sandbox-rails=<AMI_ID>
  --pb=<AMI_ID> | --prod-base=<AMI_ID>
  --pr=<AMI_ID> | --prod-rails=<AMI_ID>

EOM
}

help_me() {
  cat >&2 << EOM

Obtains information (ID/date/type/description) on most recent AMIs in each account
(sandbox/prod) generated via the terraform/imagebuild deployment infrastructure, then:
1. Verifies that the AMIs are valid (via aws ec2 describe-images)
2. Updates the corresponding values in terraform/app/variables.tf
3. Creates a branch/pull request with the new AMI IDs

The script will error out if:
- there is an active \$AWS_VAULT session running
- the \`hub\` cask is not installed (for creating a PR)
- when manually declaring AMIs, a space is used as a separator instead of the = sign
- when attempting to create a PR, there are other local changes besides
  the updates to terraform/app/variables.tf

Example output:

| AMI                    | Date                 | Account  | Description           | 
| -----                  | -----                | -----    | -----                 | 
| ami-096da794c97c82252  | 2021-08-09 21:11:56  | sandbox  | rails-20210809203848  | 
| ami-0b80f8d69529ba0a6  | 2021-08-09 20:53:03  | sandbox  | base-20210809203135   | 
| ami-0f9ede873dff2b00b  | 2021-08-08 07:33:49  | prod     | rails-20210808070419  | 
| ami-04249a1f1f1564ada  | 2021-08-08 07:25:36  | prod     | base-20210808070324   | 
EOM
  usage
  exit 0
}

needs_arg() { if [ -z "$OPTARG" ]; then raise "No arg for --$OPT option"; fi; }

# parse space/tab-separated column output and space with pipe marks
mdout() {
  echo -e "|$@|" | column -t | tr -s ' ' '|' |
  sed 's/ *| */@| /g' | column -s '@' -t
}

next_build() {
  PIPE_DATA=$(ave -r aws codepipeline list-action-executions \
    --pipeline-name ${PIPE_NAME} \
    --max-items 1 --starting-token ${PIPE_TOKEN})
  PIPE_TOKEN=$(echo ${PIPE_DATA} | jq -r '.NextToken')
}

get_ami_info() {
  PROFILE=${1}
  shift
  echo -e "\nGetting login-${PROFILE} AMI data..."
  PIPELINE_AMIS=()
  get_iam 'imagebuild' "${PROFILE}"

  for TYPE in "$@" ; do
    if [[ ${TYPE} =~ '_ami-' ]] ; then
      IMAGE=$(echo ${TYPE} | awk -F_ '{print $2}')
      TYPE=$(echo ${TYPE} | awk -F_ '{print $1}')
      echo_yellow "Using manually-specified ID ${IMAGE} for ${TYPE} AMI."
    else
      BUILD=
      PIPE_NAME=$(ave -r aws codepipeline list-pipelines | jq -r '.pipelines[].name' | grep -i ${TYPE})
      PIPE_DATA=$(ave aws codepipeline list-action-executions \
        --pipeline-name ${PIPE_NAME} --max-items 1)
      PIPE_TOKEN=$(echo ${PIPE_DATA} | jq -r '.NextToken')

      # check actionExecutionDetails of most recent CodePipeline action
      # if stageName is Build -- and Succeeded -- get the externalExecutionId to look up the AMI ID
      # if not -- and/or if the build Failed -- go to the next action
      while [[ -z ${BUILD} ]] ; do
        PIPE_BUILD=$(echo ${PIPE_DATA} | jq -r '.actionExecutionDetails[]')
        if [[ $(echo $PIPE_BUILD | jq -r '.stageName') == 'Build' ]] ; then
          if [[ $(echo $PIPE_BUILD | jq -r '.status') == "Succeeded" ]] ; then
            BUILD=$(echo ${PIPE_BUILD} |
              jq -r '.output.executionResult.externalExecutionId' |
              awk -F: '{print $NF}')
          else
            if [[ ${PIPE_TOKEN} == 'null' ]] || [[ -z ${PIPE_TOKEN} ]]; then
              # fail entirely if there are no more builds to check
              raise "${PIPE_NAME} has no successful runs; run bin/build-images and verify completion!"
            else
              next_build
            fi
          fi
        else
          next_build
        fi
      done

      IMAGE=$(ave -r aws cloudtrail lookup-events \
                        --lookup-attributes AttributeKey=EventName,AttributeValue=CopyImage |
                        jq -r --arg build "$BUILD" '.Events[].CloudTrailEvent|
                          fromjson|
                          select(.userIdentity.arn|
                          contains($build)).responseElements.imageId')
      echo_cyan "Using CodeBuild artifact ${IMAGE} for ${TYPE} AMI."
    fi
    PIPELINE_AMIS+=(${IMAGE})
  done
  DATA+=$(echo -e "\n$(ave -r aws ec2 describe-images \
              --image-ids $(echo "${PIPELINE_AMIS[*]}") \
              --query 'Images[*].[ImageId,CreationDate,Name]' \
              --output text | sort -rk2 | head -n 2 |
              sed -E "s/login\.gov (base|rails) (role )?hardened (base )?image Ubuntu 18\.04 /$PROFILE \1\-/g" |
              sed -E "s/([0-9\:]+)\.000Z/\1/g" |
              sed -E 's/^/\|/g;s/$/\|/g')\n")
}

data_table() {
  NUM_COLS=$(echo "${DATA[@]}" | awk '{print NF}' | sort -nu | tail -n 1)
  echo
  echo_green "AMI data generated:"
  echo
  mdout "${HEADERS}\n$(echo "|$(printf "%${NUM_COLS}s" |
         sed 's/ /----- |/g')")\n${DATA}" | tr 'T' ' '
}

update_vars() {
  echo -e "\nUpdating values in variables.tf file(s)..."
  local UPDATED_VARS=0
  local TF_VARS_PATH='app'
  [[ ${#DATA[@]} -eq 0 ]] && get_ami_info
  for LINE in $(echo "${DATA[@]}" | tail -n +2 | tr -d '|' |
                awk '{print $1"+"$2"+"$3"+"$4}') ; do
    AMI_ID=$(echo ${LINE} | awk -F+ '{print $1}')
    AMI_DATE=$(echo ${LINE} | awk -F+ '{print $2}' | sed -E 's/([0-9-]+)T.+/\1/')
    AMI_ACCT=$(echo ${LINE} | awk -F+ '{print $3}')
    AMI_TYPE=$(echo ${LINE} | awk -F+ '{print $4}' | sed -E 's/([a-z]+).+/\1/')
    [[ ${AMI_TYPE} == "base" ]] && AMI_TYPE='default'
    sed -i '' -E "/\"${AMI_TYPE}_ami_id_${AMI_ACCT}\"/{n;s/ami-[0-9a-f]{17}\" \# [0-9-]{10}/${AMI_ID}\" \# ${AMI_DATE}/;}" "terraform/${TF_VARS_PATH}/variables.tf"
    if [[ $(git diff -U0 | grep ${AMI_ID}) ]] ; then
      echo_green "Updated ${AMI_TYPE}_ami_id_${AMI_ACCT} to ${AMI_ID}."
      ((UPDATED_VARS++))
    fi
  done
  if [[ ${UPDATED_VARS} == 0 ]] ; then
    echo_yellow "All values in file(s) are up to date; no changes necessary."
  else
    echo_green "${UPDATED_VARS} value(s) updated."
  fi
}

open_pr() {
  DIFF_COUNT=0
  for NUM in $(git diff --numstat | awk '{print $1}' | tr '\n' ' ') ; do
    DIFF_COUNT=$(expr $DIFF_COUNT + $NUM)
  done
  if [[ ${DIFF_COUNT} != 4 ]] ; then
    raise "4 lines should be changed for an AMI update PR; ${DIFF_COUNT} lines changed instead. Verify and try again."
  fi
  
  [[ ${#DATA[@]} -eq 0 ]] && get_ami_info
  if [[ ! $(brew list --formula | grep hub) ]] ; then
    brew install hub || raise "hub not installed!"
  fi
  AMI_BRANCH="ami/$(date -j '+%Y%m%d')"
  echo -e "\nCreating ${AMI_BRANCH} branch + opening pull request..."
  PR_TITLE="AMI update, $(date -j '+%Y-%m-%d')"
  gh_revs
  run git checkout main
  run git pull origin main
  run git checkout -b ${AMI_BRANCH}
  run git add --all
  run git commit -m "${PR_TITLE}"
  run git push --set-upstream origin ${AMI_BRANCH}
  hub pull-request -p -r "${GH_REVS}" -e -m "$(cat <<EOF
${PR_TITLE}

$(mdout "${HEADERS}\n$(echo "|$(printf "%${NUM_COLS}s" | sed 's/ /----- |/g')")\n${DATA}" | tr 'T' ' ')


EOF
)"
}

##### main script

if [[ $(env | grep 'AWS_VAULT=') ]] ; then
  raise "Cannot run with an active AWS_VAULT session; clear the session and try again!"
fi

verify_root_repo

HEADERS="|AMI Date Account Description|"
TASK_LIST='update open'
TYPE_LIST='base rails'
SANDBOX_AMIS='sandbox '
PROD_AMIS='prod '
DATA=()
AV_PROFILE=

while getopts luobrh-: OPT; do
  # support long options: https://stackoverflow.com/a/28466267/519360
  if [ "$OPT" = "-" ]; then   # long option: reformulate OPT and OPTARG
    OPT="${OPTARG%%=*}"       # extract long option name
    OPTARG="${OPTARG#$OPT}"   # extract long option argument (may be empty)
    OPTARG="${OPTARG#=}"      # if long option argument, remove assigning `=`
  fi
  
  case "$OPT" in
    sb|sandbox-base)  needs_arg; SANDBOX_AMIS+="base_$OPTARG "  ;;
    sr|sandbox-rails) needs_arg; SANDBOX_AMIS+="rails_$OPTARG " ;;
    pb|prod-base)     needs_arg; PROD_AMIS+="base_$OPTARG "     ;;
    pr|prod-rails)    needs_arg; PROD_AMIS+="rails_$OPTARG "    ;;
    l) TASK_LIST=         ;;
    u) TASK_LIST='update' ;;
    o) TASK_LIST='open'   ;;
    b) TYPE_LIST='base'   ;;
    r) TYPE_LIST='rails'  ;;
    h) help_me            ;;
    ??* ) raise "Illegal option --$OPT" ;;  # bad long option
    ? )   usage && exit 2 ;;  # bad short option (error reported via getopts)
  esac
done
shift $((OPTIND-1)) # remove parsed options and args from $@ list

for TYPE in ${TYPE_LIST} ; do
  [[ $SANDBOX_AMIS =~ $TYPE ]] || SANDBOX_AMIS+="${TYPE} "
  [[ $PROD_AMIS =~ $TYPE ]] || PROD_AMIS+="${TYPE} "
done

if [[ "${TASK_LIST}" =~ (open) ]] ; then
  if ! [[ -z $(git diff --name-only | grep -v 'terraform/app/variables.tf') ]] ; then
    raise "Cannot create PR; additional changes found outside of terraform/app/variables.tf file."
  fi
fi

get_ami_info $SANDBOX_AMIS
get_ami_info $PROD_AMIS
data_table

for TASK in ${TASK_LIST} ; do
  case "${TASK}" in
    update) update_vars  ;;
    open)   open_pr      ;;
  esac
done
echo
