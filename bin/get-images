#!/bin/bash

#### Grab AMI data and build a PR with it! ####

set -euo pipefail

. "$(dirname "$0")/lib/common.sh"

usage() {
  cat >&2 << EOM

Usage: ${0} [-luogh]

Flags (will run all, EXCEPT -g, if no flags specified):
  -l : Show AMI data output table only
  -u : Update ami_id values in terraform/app/variables.tf
  -o : Create ami/DATE branch + open a PR with ami_id changes
  -g : Update default_ami_id_tooling values in terraform/gitlab/*/main.tf
  -h : Detailed help

Manually set AMIs for specific account and/or type:
  --sb=<AMI_ID> | --sandbox-base=<AMI_ID>
  --sr=<AMI_ID> | --sandbox-rails=<AMI_ID>
  --pb=<AMI_ID> | --prod-base=<AMI_ID>
  --pr=<AMI_ID> | --prod-rails=<AMI_ID>
  --ts=<AMI_ID> | --tooling-sandbox=<AMI_ID>
  --tp=<AMI_ID> | --tooling-prod=<AMI_ID>

EOM
}

help_me() {
  cat >&2 << EOM

Obtains information (ID/date/type/description) on most recent AMIs in each account
(sandbox/prod/tooling-sandbox/tooling-prod) generated via the terraform/imagebuild
deployment infrastructure, then:

1. Verifies that the AMIs are valid (via aws ec2 describe-images)
2. Updates the corresponding values in terraform/app/variables.tf
3. Creates a branch/pull request with the new AMI IDs

If the -g flag is set, it will also update the default_ami_id_tooling value(s) in
each of the environment-specific main.tf files in terraform/gitlab as well.

The script will error out if:
- there is an active \$AWS_VAULT session running
- the \`hub\` cask is not installed (for creating a PR)
- when manually declaring AMIs, a space is used as a separator instead of the = sign
- when attempting to create a PR, there are other local changes besides the updates
  to terraform/app/variables.tf (and terraform/gitlab/*/main.tf if -g is set)

Example output:

| AMI                   | Date                | Account      | Description          | 
| -----                 | -----               | -----        | -----                | 
| ami-01780a49bf5991d91 | 2022-04-27 07:43:34 | sandbox      | rails-20220427070429 | 
| ami-0c581634d34853649 | 2022-04-27 07:33:32 | sandbox      | base-20220427070411  | 
| ami-087d5aac204147f66 | 2022-04-27 07:36:27 | prod         | rails-20220427070425 | 
| ami-04584dc44a85e2a7a | 2022-04-27 07:28:24 | prod         | base-20220427070422  | 
| ami-08e6c2173d14752cc | 2022-04-27 07:29:16 | tooling      | base-20220427070432  | 
| ami-0ca7ae578890c36e1 | 2022-04-27 07:30:19 | tooling-prod | base-20220427070424  | 
EOM
  usage
  exit 0
}

needs_arg() { if [ -z "$OPTARG" ]; then raise "No arg for --$OPT option"; fi; }

next_build() {
  PIPE_DATA=$(ave -r aws codepipeline list-action-executions \
    --pipeline-name ${PIPE_NAME} \
    --max-items 1 --starting-token ${PIPE_TOKEN})
  PIPE_TOKEN=$(echo ${PIPE_DATA} | jq -r '.NextToken')
}

get_pipeline_ami() {
  local AMI_TYPE="${1}"
  local BUILD
  local BAD_BUILDS=0
  PIPE_NAME=$(ave -r aws codepipeline list-pipelines | jq -r '.pipelines[].name' | grep -i ${AMI_TYPE})
  PIPE_DATA=$(ave aws codepipeline list-action-executions \
    --pipeline-name ${PIPE_NAME} --max-items 1)
  PIPE_TOKEN=$(echo ${PIPE_DATA} | jq -r '.NextToken')
  # check actionExecutionDetails of most recent CodePipeline action
  # if stageName is Build -- and Succeeded -- get the externalExecutionId to look up the AMI ID
  # if not -- and/or if the build Failed -- go to the next action
  while [[ -z ${BUILD} ]] ; do
    PIPE_BUILD=$(echo ${PIPE_DATA} | jq -r '.actionExecutionDetails[]')
    if [[ $(echo $PIPE_BUILD | jq -r '.stageName') == 'Build' ]] ; then
      if [[ $(echo $PIPE_BUILD | jq -r '.status') == "Succeeded" ]] ; then
        BUILD=$(echo ${PIPE_BUILD} |
          jq -r '.output.executionResult.externalExecutionId' |
          awk -F: '{print $NF}')
      else
        if [[ ${PIPE_TOKEN} == 'null' ]] || [[ -z ${PIPE_TOKEN} ]]; then
          # fail entirely if there are no more builds to check
          raise "${PIPE_NAME} has no successful runs; run bin/build-images and verify completion!"
        else
          ((BAD_BUILDS++))
          next_build
        fi
      fi
    else
      next_build
    fi
  done
  if [[ ${BAD_BUILDS} -gt 0 ]] ; then
    BAD_IMAGE_DATA+=("${PROFILE}/${AMI_TYPE}/${BAD_BUILDS}")
  fi
  IMAGE=$(ave -r aws cloudtrail lookup-events \
                    --lookup-attributes AttributeKey=EventName,AttributeValue=CopyImage |
                    jq -r --arg build "$BUILD" '.Events[].CloudTrailEvent|
                      fromjson|
                      select(.userIdentity.arn|
                      contains($build)).responseElements.imageId')
  echo_cyan "Using CodeBuild artifact ${IMAGE} for ${AMI_TYPE} AMI."
}

get_ami_info() {
  PROFILE=${1}
  shift
  echo -e "\nGetting login-${PROFILE} AMI data..."
  NEW_AMIS=()
  get_iam 'imagebuild' "${PROFILE}" 'FullAdministrator'

  for TYPE in "$@" ; do
    if [[ ${TYPE} =~ '_ami-' ]] ; then
      IMAGE=$(echo ${TYPE} | awk -F_ '{print $2}')
      TYPE=$(echo ${TYPE} | awk -F_ '{print $1}')
      echo_yellow "Using manually-specified ID ${IMAGE} for ${TYPE} AMI."
    else
      get_pipeline_ami "${TYPE}"
    fi
    NEW_AMIS+=(${IMAGE})
  done
  DATA+=$(echo -e "\n$(ave -r aws ec2 describe-images \
              --image-ids $(echo "${NEW_AMIS[*]}") \
              --query 'Images[*].[ImageId,CreationDate,Name]' \
              --output text | sort -rk2 | head -n 2 |
              sed -E "s/login\.gov (base|rails) (role )?hardened (base )?image Ubuntu 18\.04 /$PROFILE \1\-/g" |
              sed -E "s/([0-9\:]+)\.000Z/\1/g" |
              sed -E 's/^/\|/g;s/$/\|/g')\n")
}

data_table() {
  NUM_COLS=$(echo "${DATA[@]}" | awk '{print NF}' | sort -nu | tail -n 1)
  echo
  echo_green "AMI data generated:"
  echo
  mdout "${HEADERS}\n$(echo "|$(printf "%${NUM_COLS}s" |
         sed 's/ /----- |/g')")\n${DATA}" | tr 'T' ' '
  if [[ ${#BAD_IMAGE_DATA[@]} -gt 0 ]] ; then
    echo && echo_yellow "One or more pipelines had failing builds:"
    for BAD_PIPELINE in "${BAD_IMAGE_DATA[@]}" ; do
      PIPE_INFO=($(echo ${BAD_PIPELINE} | tr '/' ' '))
      echo "login-${PIPE_INFO[0]} : ${PIPE_INFO[1]} : ${PIPE_INFO[2]} build(s)"
    done
    echo_yellow "Verify status of above pipeline(s) when creating an AMI PR!"
    echo
  fi
}

update_vars() {
  echo -e "\nUpdating values in variables.tf file(s)...\n"
  local UPDATES=('FILE:TERRAFORM@VAR:NEW@VALUE' '-----:-----:-----')
  [[ ${#DATA[@]} -eq 0 ]] && get_ami_info
  for LINE in $(echo "${DATA[@]}" | tail -n +2 | tr -d '|' |
                awk '{print $1"+"$2"+"$3"+"$4}') ; do
    local TF_VARS_PATHS=()
    AMI_ID=$(echo ${LINE} | awk -F+ '{print $1}')
    AMI_DATE=$(echo ${LINE} | awk -F+ '{print $2}' | sed -E 's/([0-9-]+)T.+/\1/')
    AMI_ACCT=$(echo ${LINE} | awk -F+ '{print $3}')
    AMI_TYPE=$(echo ${LINE} | awk -F+ '{print $4}' | sed -E 's/([a-z]+).+/\1/')
    [[ ${AMI_TYPE} == "base" ]] && AMI_TYPE='default'
    if [[ ${GITLAB_AMIS} == true ]] && [[ "${AMI_ACCT}" =~ 'tooling' ]]; then
      if [[ "${AMI_ACCT}" == 'tooling-prod' ]]; then
        TF_VARS_PATHS+=('terraform/gitlab/production/main.tf')
      else
        for MAIN_TF in $(find "${GIT_DIR}/terraform/gitlab" -type f -name 'main.tf' \
          ! -path "*tfstate*" ! -path "*\.terraform*" ! -path "*prod*" | tr '\n' ' ') ; do
          if [[ $(grep 'allowed_account_ids' "${MAIN_TF}") ]] ; then
            TF_VARS_PATHS+=($(echo "${MAIN_TF}" | sed -E 's/.+(terraform\/)/\1/'))
          fi
        done
      fi
    else
      TF_VARS_PATHS+=('terraform/app/variables.tf')
    fi
    for VAR_PATH in "${TF_VARS_PATHS[@]}" ; do
      if [[ "${VAR_PATH}" =~ 'app' ]] ; then
        sed -i '' -E "/\"${AMI_TYPE}_ami_id_${AMI_ACCT}\"/{n;s/\
ami-[0-9a-f]{17}\" \# [0-9-]{10}/${AMI_ID}\" \# ${AMI_DATE}/;}" "${GIT_DIR}/${VAR_PATH}"
      else
        AMI_DATE_SHORT=$(echo ${LINE} | awk -F+ '{print $2}' | sed 's/[-: T]//g')
        sed -i '' -E "s/ami-.+ ([a-z-]+)[0-9]{14}/\
${AMI_ID}\" # ${AMI_DATE} \1${AMI_DATE_SHORT}/" "${GIT_DIR}/${VAR_PATH}"
      fi
      if [[ $(git diff -U0 | grep ${AMI_ID}) ]] && [[ $(git diff --name-only | grep "${VAR_PATH}" ) ]]; then
        UPDATES+=("${VAR_PATH}:${AMI_TYPE}_ami_id_${AMI_ACCT}:${AMI_ID}")
        ((UPDATED_VARS++))
      fi
      if [[ ! "${AMI_FILES[@]:-}" =~ ${VAR_PATH} ]] ; then
        AMI_FILES+=(${VAR_PATH})
      fi
    done
  done
  if [[ ${UPDATED_VARS} == 0 ]] ; then
    echo_yellow "All values in file(s) are up to date; no changes necessary."
  else
    echo_green "$(echo ${UPDATES[@]} | tr ' ' '\n' | column -t -s ':' | tr '@' ' ')"
  fi
  echo
}

open_pr() {
  local DIFF=($(git diff --name-only))
  local UNSCOPED=$(echo "${DIFF[@]}" "${AMI_FILES[@]}" | tr ' ' '\n' | sort | uniq -u)
  if [[ ! -z "${UNSCOPED}" ]] ; then
    echo_red "Additional files found in diff:"
    for FILE in "${UNSCOPED}" ; do
      echo_red "- ${FILE}"
    done
    echo
    raise "Verify changed files and try again."
  fi
  
  [[ ${#DATA[@]} -eq 0 ]] && get_ami_info
  if [[ ! $(brew list --formula | grep hub) ]] ; then
    brew install hub || raise "hub not installed!"
  fi
  AMI_BRANCH="ami/$(date -j '+%Y%m%d')"
  echo -e "\nCreating ${AMI_BRANCH} branch + opening pull request..."
  PR_TITLE="AMI update, $(date -j '+%Y-%m-%d')"
  gh_revs
  run git checkout main
  run git pull origin main
  run git checkout -b ${AMI_BRANCH}
  run git add --all
  run git commit -m "${PR_TITLE}"
  run git push --set-upstream origin ${AMI_BRANCH}
  run hub pull-request -p -r "${GH_REVS}" -e -m "$(cat <<EOF
${PR_TITLE}

$(mdout "${HEADERS}\n$(echo "|$(printf "%${NUM_COLS}s" | sed 's/ /----- |/g')")\n${DATA}" | tr 'T' ' ')


EOF
)"
}

##### main script

if [[ $(env | grep 'AWS_VAULT=') ]] ; then
  raise "Cannot run with an active AWS_VAULT session; clear the session and try again!"
fi

verify_root_repo

DATA=()
BAD_IMAGE_DATA=()
AMI_FILES=()
AV_PROFILE=
UPDATED_VARS=0
GITLAB_AMIS=false
HEADERS="|AMI Date Account Description|"

TASK_LIST=('list' 'update' 'open')
SANDBOX_AMIS=('sandbox')
PROD_AMIS=('prod')
TOOLING_SANDBOX_AMIS=('tooling')
TOOLING_PROD_AMIS=('tooling-prod')

while getopts luogh-: OPT; do
  # support long options: https://stackoverflow.com/a/28466267/519360
  if [ "$OPT" = "-" ]; then   # long option: reformulate OPT and OPTARG
    OPT="${OPTARG%%=*}"       # extract long option name
    OPTARG="${OPTARG#$OPT}"   # extract long option argument (may be empty)
    OPTARG="${OPTARG#=}"      # if long option argument, remove assigning `=`
  fi
  
  case "$OPT" in
    sb|sandbox-base)    needs_arg; SANDBOX_AMIS+=("base_$OPTARG")         ;;
    sr|sandbox-rails)   needs_arg; SANDBOX_AMIS+=("rails_$OPTARG")        ;;
    pb|prod-base)       needs_arg; PROD_AMIS+=("base_$OPTARG")            ;;
    pr|prod-rails)      needs_arg; PROD_AMIS+=("rails_$OPTARG")           ;;
    ts|tooling-sandbox) needs_arg; TOOLING_SANDBOX_AMIS+=("base_$OPTARG") ;;
    tp|tooling-prod)    needs_arg; TOOLING_PROD_AMIS+=("base_$OPTARG")    ;;
    l) TASK_LIST=('list')          ;;
    u) TASK_LIST=('list' 'update') ;;
    o) TASK_LIST=('list' 'open')   ;;
    g) GITLAB_AMIS=true            ;;
    h) help_me                     ;;
    ??* ) raise "Illegal option --$OPT" ;;  # bad long option
    ? )   usage && exit 2 ;;  # bad short option (error reported via getopts)
  esac
done
shift $((OPTIND-1)) # remove parsed options and args from $@ list

for TYPE in 'base' 'rails' ;  do
  [[ "${SANDBOX_AMIS[@]}" =~ $TYPE ]] || SANDBOX_AMIS+=("${TYPE}")
  [[ "${PROD_AMIS[@]}"    =~ $TYPE ]] || PROD_AMIS+=("${TYPE}")
done
[[ "${TOOLING_SANDBOX_AMIS[@]}" =~ 'base' ]] || TOOLING_SANDBOX_AMIS+=('base')
[[ "${TOOLING_PROD_AMIS[@]}"    =~ 'base' ]] || TOOLING_PROD_AMIS+=('base')

get_ami_info "${SANDBOX_AMIS[@]}"
get_ami_info "${PROD_AMIS[@]}"
get_ami_info "${TOOLING_SANDBOX_AMIS[@]}"
get_ami_info "${TOOLING_PROD_AMIS[@]}"

for TASK in "${TASK_LIST[@]}" ; do
  case "${TASK}" in
    list)   data_table  ;;
    update) update_vars ;;
    open)   open_pr     ;;
  esac
done
echo
