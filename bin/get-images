#!/bin/bash

# Grab AMI data and build a PR with it!

set -euo pipefail

. "$(dirname "$0")/lib/common.sh"

usage() {
  cat >&2 << EOM

Usage: ${0} [-uospbr]

Flags (will run all if no flags specified):
  -l : Show AMI data output table only
  -u : Update \`ami_id\` values in \`terraform/app/variables.tf\`
  -o : Create \`ami/DATE\` branch + open a PR with \`ami_id\` changes
  -h : Detailed help

Manually set AMIs for specific account and/or type:
  --sb=<AMI_ID> | --sandbox-base=<AMI_ID>
  --sr=<AMI_ID> | --sandbox-rails=<AMI_ID>
  --pb=<AMI_ID> | --prod-base=<AMI_ID>
  --pr=<AMI_ID> | --prod-rails=<AMI_ID>

EOM
}

man_page() {
    cat >&2 << EOM
Usage: ${0} [-uospbr]

1. Obtains information (ID / date / type / description) on
the most recent AMIs in each account (\`sandbox\` / \`prod\` / \`tooling\`)
that were generated via the terraform/imagebuild deployment
infrastructure (i.e. CodeBuild / CodePipeline)
2. Verifies that the AMIs are valid (via \`aws ec2 describe-images\`)
3. Updates the corresponding values in \`terraform/app/variables.tf\`,
4. Creates a branch/pull request with the new AMI IDs.

Designed to run with no specified flags/arguments; however,
individual commands/parameters for the script can be specified
with the following flags:

  -l : Only generate the AMI data table, then exit
  -u : Update \`ami_id\` values in \`terraform/app/variables.tf\`
  -o : Create a new branch, \`ami/DATE\` branch, commit the
       changes to \`terraform/app/variables.tf\`, and open a
       PR with the generated table data for the body
  -b : Only update the \`base\` AMI IDs
  -r : Only update the \`rails\` AMI IDs
  -h : Display this help

If specific AMI IDs are declared as arguments, with appropriate
flags, the script will use that/those AMI(s) instead of the most
recent CodeBuild artifact(s) -- ideal in case there is an error
with a recent build, and the previous build/another AMI should
be used instead:

  --sb=<AMI_ID> | --sandbox-base=<AMI_ID>
  --sr=<AMI_ID> | --sandbox-rails=<AMI_ID>
  --pb=<AMI_ID> | --prod-base=<AMI_ID>
  --pr=<AMI_ID> | --prod-rails=<AMI_ID>

The script will then proceed normally, checking CodeBuild for
whichever AMIs are _not_ manually specified using one or more of
these flags, generating the data table, etc.

The script will error out if:
- there is an active \`\$AWS_VAULT\` session running (as it needs access
  to multiple AWS profiles to get the AMI IDs)
- the \`hub\` cask is not installed (for creating a PR)
- if, when manually declaring AMIs, the \`=\` sign is not provided, or
  a space is used as a separator instead
- if, when attempting to create a PR, there are other local changes besides
  the updates to \`terraform/app/variables.tf\`

Example output:

| AMI                    | Date                 | Account  | Description       | 
| -----                  | -----                | -----    | -----             | 
| ami-06caaf2dfa83c916a  | 2020-07-26 07:34:42  | sandbox  | rails-1595747102  | 
| ami-0d7fa0b06192e40be  | 2020-07-26 07:26:07  | sandbox  | base-1595747084   | 
| ami-08f2f56c85f56615f  | 2020-07-21 18:25:58  | prod     | rails-1595344038  | 
| ami-0a37be06240f1d943  | 2020-07-21 18:20:19  | prod     | rails-1595344038  | 

EOM

exit 0
}

needs_arg() { if [ -z "$OPTARG" ]; then raise "No arg for --$OPT option"; fi; }

# parse space/tab-separated column output and space with pipe marks
mdout() {
  echo -e "|$@|" | column -t | tr -s ' ' '|' |
  sed 's/ *| */@| /g' | column -s '@' -t
}

get_pipeline_data() {
  local ROLE=${1}
}

get_ami_info() {
  PROFILE=${1}
  shift
  echo -e "\nGetting \`login-${PROFILE}\` AMI data..."
  PIPELINE_AMIS=()
  AV_PROFILE=$(get_profile_name $(get_acct_num ${PROFILE}))

  for TYPE in "$@" ; do
    if [[ ${TYPE} =~ '_ami-' ]] ; then
      IMAGE=$(echo ${TYPE} | awk -F_ '{print $2}')
      TYPE=$(echo ${TYPE} | awk -F_ '{print $1}')
      echo_yellow "Using manually-specified ID \`${IMAGE}\` for \`${TYPE}\` AMI."
    else
      BUILD=
      PIPE_NAME=$(ave -r aws codepipeline list-pipelines | jq -r '.pipelines[].name' | grep -i ${TYPE})
      PIPE_DATA=$(ave aws codepipeline list-action-executions --pipeline-name ${PIPE_NAME} --max-items 2)
      while [[ -z ${BUILD} ]] ; do
        PIPE_TOKEN=$(echo ${PIPE_DATA} | jq -r '.NextToken')
        PIPE_BUILD=$(echo ${PIPE_DATA} | jq -r '.actionExecutionDetails[]|select(.stageName == "Build")')
        if ! [[ $(echo $PIPE_BUILD | jq -r .status) == "Succeeded" ]] ; then
          PIPE_DATA=$(ave -r aws codepipeline list-action-executions \
            --pipeline-name ${PIPE_NAME} \
            --max-items 2 --starting-token ${PIPE_TOKEN})
        else
          BUILD=$(echo ${PIPE_BUILD} |
            jq -r '.output.executionResult.externalExecutionId' |
            awk -F: '{print $NF}')
        fi
      done
      IMAGE=$(ave -r aws cloudtrail lookup-events \
                        --lookup-attributes AttributeKey=EventName,AttributeValue=CopyImage |
                        jq -r --arg build "$BUILD" '.Events[].CloudTrailEvent|
                          fromjson|
                          select(.userIdentity.arn|
                          contains($build)).responseElements.imageId')
      echo_cyan "Using CodeBuild artifact \`${IMAGE}\` for \`${TYPE}\` AMI."
    fi
    PIPELINE_AMIS+=(${IMAGE})
  done
  DATA+=$(echo -e "\n$(ave -r aws ec2 describe-images \
              --image-ids $(echo "${PIPELINE_AMIS[*]}") \
              --query 'Images[*].[ImageId,CreationDate,Name]' \
              --output text | sort -rk2 | head -n 2 |
              sed -E "s/login\.gov (base|rails) (role )?hardened (base )?image Ubuntu 18\.04 /$PROFILE \1\-/g" |
              sed -E "s/([0-9\:]+)\.000Z/\1/g" |
              sed -E 's/^/\|/g;s/$/\|/g')\n")
}

data_table() {
  NUM_COLS=$(echo "${DATA[@]}" | awk '{print NF}' | sort -nu | tail -n 1)
  echo
  echo_green "AMI data generated:"
  echo
  mdout "${HEADERS}\n$(echo "|$(printf "%${NUM_COLS}s" |
         sed 's/ /----- |/g')")\n${DATA}" | tr 'T' ' '
}

update_vars() {
  echo -e "\nUpdating values in \`terraform/app/variables.tf\`..."
  [[ ${#DATA[@]} -eq 0 ]] && get_ami_info
  for LINE in $(echo "${DATA[@]}" | tail -n +2 | tr -d '|' |
                awk '{print $1"+"$2"+"$3"+"$4}') ; do
    AMI_ID=$(echo ${LINE} | awk -F+ '{print $1}')
    AMI_DATE=$(echo ${LINE} | awk -F+ '{print $2}' | sed -E 's/([0-9-]+)T.+/\1/')
    AMI_ACCT=$(echo ${LINE} | awk -F+ '{print $3}')
    AMI_TYPE=$(echo ${LINE} | awk -F+ '{print $4}' | sed -E 's/([a-z]+).+/\1/')
    [[ ${AMI_TYPE} == "base" ]] && AMI_TYPE='default'
    sed -i '' -E "/\"${AMI_TYPE}_ami_id_${AMI_ACCT}\"/{n;s/ami-[0-9a-f]{17}\" \# [0-9-]{10}/${AMI_ID}\" \# ${AMI_DATE}/;}" terraform/app/variables.tf
    if [[ $(git diff -U0 | grep ${AMI_ID}) ]] ; then
      echo_green "Updated \`${AMI_TYPE}_ami_id_${AMI_ACCT}\` to \`${AMI_ID}\`."
    fi
  done
}

open_pr() {
  DIFF_COUNT=$(git diff --numstat | awk '{print $1}')
  if [[ ${DIFF_COUNT} != 4 ]] ; then
    raise "4 lines should be changed for an AMI update PR; ${DIFF_COUNT} lines changed instead. Verify and try again."
  fi
  
  [[ ${#DATA[@]} -eq 0 ]] && get_ami_info
  if [[ ! $(brew list --formula | grep hub) ]] ; then
    brew install hub || raise "hub not installed!"
  fi
  AMI_BRANCH="ami/$(date -j '+%Y%m%d')"
  echo -e "\nCreating \`${AMI_BRANCH}\` branch + opening pull request..."
  PR_TITLE="AMI update, $(date -j '+%Y-%m-%d')"
  gh_revs
  run git checkout main
  run git pull origin main
  run git checkout -b ${AMI_BRANCH}
  run git add --all
  run git commit -m \"'${PR_TITLE}'\"
  run git push --set-upstream origin ${AMI_BRANCH}
  hub pull-request -p -r "${GH_REVS}" -e -m "$(cat <<EOF
${PR_TITLE}

$(mdout "${HEADERS}\n$(echo "|$(printf "%${NUM_COLS}s" | sed 's/ /----- |/g')")\n${DATA}" | tr 'T' ' ')


EOF
)"
}

##### main script

if [[ $(env | grep 'AWS_VAULT=') ]] ; then
  raise "Cannot run with an active AWS_VAULT session; clear the session and try again!"
fi

verify_root_repo

HEADERS="|AMI Date Account Description|"
TASK_LIST='update open'
SANDBOX_AMIS='sandbox '
PROD_AMIS='prod '
TOOLING_AMIS='tooling '
DATA=()

while getopts luoh-: OPT; do
  # support long options: https://stackoverflow.com/a/28466267/519360
  if [ "$OPT" = "-" ]; then   # long option: reformulate OPT and OPTARG
    OPT="${OPTARG%%=*}"       # extract long option name
    OPTARG="${OPTARG#$OPT}"   # extract long option argument (may be empty)
    OPTARG="${OPTARG#=}"      # if long option argument, remove assigning `=`
  fi
  
  case "$OPT" in
    sb|sandbox-base)  needs_arg; SANDBOX_AMIS+="base_$OPTARG " ;;
    sr|sandbox-rails) needs_arg; SANDBOX_AMIS+="rails_$OPTARG " ;;
    pb|prod-base)  needs_arg; PROD_AMIS+="base_$OPTARG" ;;
    pr|prod-rails) needs_arg; PROD_AMIS+="rails_$OPTARG" ;;
    l) TASK_LIST=                         ;;
    u) TASK_LIST='update'                 ;;
    o) TASK_LIST='open'                   ;;
    h) man_page ;;
    ??* )          raise "Illegal option --$OPT" ;;  # bad long option
    ? )            exit 2 ;;  # bad short option (error reported via getopts)
  esac
done
shift $((OPTIND-1)) # remove parsed options and args from $@ list

for TYPE in base rails ; do
  [[ $SANDBOX_AMIS =~ $TYPE ]] || SANDBOX_AMIS+="${TYPE} "
  [[ $PROD_AMIS =~ $TYPE ]] || PROD_AMIS+="${TYPE} "
  [[ $TOOLING_AMIS =~ $TYPE ]] || TOOLING_AMIS+="${TYPE} "
done

if [[ "${TASK_LIST}" =~ (open) ]] ; then
  if ! [[ -z $(git diff --name-only | grep -v 'terraform/app/variables.tf') ]] ; then
    raise "Cannot create PR; additional changes found outside of terraform/app/variables.tf file."
  fi
fi

get_ami_info $SANDBOX_AMIS
get_ami_info $PROD_AMIS
get_ami_info $TOOLING_AMIS
data_table

for TASK in ${TASK_LIST} ; do
  case "${TASK}" in
    update) update_vars  ;;
    open)   open_pr      ;;
  esac
done
echo
