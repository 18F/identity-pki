#!/usr/bin/env bash

trap fix_local_lockfile EXIT

# function to exit process with error message
die() { echo_red "$*" >&2 ; exit 1; }

# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail

# Try really hard not to let anything accidentally write to stdout.
# Point stdout at stderr and open FD 3 to point to the original stdout.
# Use echo >&3 to write to stdout hereafter.
exec 3>&1 1>&2

basename="$(basename "$0")"

usage() {
    cat >&2 <<EOM
# identity-devops-private configs:
usage: $basename [OPTIONS] ENV_NAME TERRAFORM_DIR [TERRAFORM_COMMANDS...]

# newer module-style configs:
usage: $basename [OPTIONS] TERRAFORM_DIR/ENV_NAME [TERRAFORM_COMMANDS...]

Run TERRAFORM_COMMANDS against environment ENV_NAME using the configuration in
TERRAFORM_DIR. Sends a message to the environment's appropriate Slack channel
if the command run is "apply" or "destroy".

Arguments:

    TERRAFORM_DIR:
        Directory path relative to the repo root to a terraform directory such
        as "terraform_app"

    ENV_NAME:
        Environment name for the deployment, e.g. "dev", "prod", or "global".
        The specifics will differ between terraform dirs.

    TERRAFORM_COMMANDS:
        Arguments and options passed to terraform, such as "plan", "apply", or
        "state list".   Use the special command "shell" to enter a subshell
        with a ready to use environment for Terraform to use.

Options:

    -h, --help              Display this message
    --import-remote-state   Bootstrap terraform remote state management by
                            importing into terraform management the terraform
                            remote state S3 bucket and DynamoDB table that are
                            used to manage TF remote state, which are
                            automatically created by configure_state_bucket.sh.
    -t, --test              Skip sending a message to Slack whether or not
                            the operation is successful. Useful when testing
                            errors that "plan" does not detect.
    -z, --zero-out-hosts    In addition to the other loaded .tfvars files,
                            load the tf_zero.tfvars file which overrides all
                            asg_*_min / asg_*_desired values with 0. Can be
                            used anytime, but is necessary when (re)building an
                            environment from scratch.
    -m, --migration-host    In addition to the other loaded .tfvars files,
                            load the tf_migrate.tfvars file which sets the
                            asg_migration_desired count to 1. Can be used
                            anytime, but is necessary when building an environment
                            from scratch, in order to allow DB migrations
                            to be executed by a migration host.
    -l, --local-lockfile    Skip copying .terraform.lock.hcl from the repo root,
                            and use/regenerate the one in the specified
                            Terraform directory. (See the HACK below for more
                            information on this.)

For older terraform directories that use identity-devops-private, env-specific
config variables will be loaded automatically from identity-devops-private.
This script will automatically delete .terraform/ and set it up as a symlink to
a common .deploy/ subdirectory.
Example:
    $basename dev app plan

For newer terraform directories that use module-style configuration, any
env-specific config variables will be loaded directly from the specified
subdirectory, and identity-devops-private will not be used. In this mode,
.terraform/ is left as-is and not managed specially, which makes it easier to
use terraform without invoking this script.
Example:
    $basename sms/sandbox plan

EOM
}

# usage: module_style_check_required_files TF_DIR
module_style_check_required_files() {
    local tf_dir
    tf_dir="terraform/$1"

    if [ ! -e "$tf_dir/main.tf" ]; then
        echo_red >&2 "$basename: No such file: $tf_dir/main.tf"
        echo_red >&2 "Are you sure that $tf_dir is a module-style TF_DIR?"
        return 1
    fi
    if [ ! -e "$tf_dir/env-vars.sh" ]; then
        echo_red >&2 "$basename: No such file: $tf_dir/env-vars.sh"
        echo_red >&2 "Are you sure that $tf_dir is a module-style TF_DIR?"
        return 1
    fi
}

# usage: verify_not_module_style
#
# Variables: $TF_DIR, $ENVIRONMENT
#
# Ensure that the target directory is not a module/subdirectory style TF_DIR.
#
verify_not_module_style() {
    local tf_dir test_file
    tf_dir="terraform/$TF_DIR/$ENVIRONMENT"

    test_file="$tf_dir/env-vars.sh"

    if [ -e "$test_file" ]; then
        echo_red >&2 "
Error: mismatch between expected and apparent .terraform directory style.
I thought this was a shared-style TF_DIR that uses identity-devops-private.
However, it contains the env-vars.sh that is only supposed to exist in
module/subdirectory style TF_DIRs.

$basename: file unexpectedly exists: $test_file
Are you sure that $tf_dir is a shared-style TF_DIR?

Try instead:
    $basename $TF_DIR/$ENVIRONMENT ${TF_CMD[*]}
"
        return 1
    fi
}


if [ $# -lt 2 ]; then
    usage
    exit 1
fi

repo_root_before_cd="$(git rev-parse --show-toplevel 2>/dev/null || true)"
DEPLOY_FAIL=false

# This script assumes it is being run from the repo root.
cd "$(dirname "$0")"
cd "$(git rev-parse --show-toplevel)"

# shellcheck source=/dev/null
. "./bin/lib/common.sh"

# Make sure our repo root didn't change after cd, because that implies that the
# user is running a different script than they expected.
verify_repo_root_unchanged "$repo_root_before_cd" "$basename"

ORIGIN_REMOTE_NAME="${ORIGIN_REMOTE_NAME-origin}"

# Parse options
declare {IMPORT_REMOTE_STATE,TEST_ONLY,EXTRA_ENV}=
TERRAFORM_SLACK_CHANNEL=0
LOCAL_LOCKFILE=0
while [ $# -gt 0 ] && [[ $1 == -* ]]; do
    case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -t|--test)
            TEST_ONLY=1
            ;;
        -l|--local-lockfile)
            LOCAL_LOCKFILE=1
            ;;
        -z|--zero-out-hosts)
            EXTRA_ENV="tf_zero"
            ;;
        -m|--migration-host)
            EXTRA_ENV="tf_migrate"
            ;;
        --import-remote-state)
            IMPORT_REMOTE_STATE=1
            ;;
        *)
            usage
            exit 1
            ;;
    esac
    shift
done

fix_local_lockfile(){
    local LOCKFILE_DIR="${repo_root_before_cd}/terraform/${TF_DIR_FULL}"
    if [ "${LOCAL_LOCKFILE}" == 0 ] && [ ! -L "${LOCKFILE_DIR}/.terraform.lock.hcl" ]; then
        cd "${LOCKFILE_DIR}"
        [ -f ".terraform.lock.hcl" ] && rm "${LOCKFILE_DIR}/.terraform.lock.hcl"
        if [ -n "$MODULE_STYLE" ]; then
            ln -s ../../../.terraform.lock.hcl .terraform.lock.hcl
        else
            ln -s ../../.terraform.lock.hcl .terraform.lock.hcl
        fi
        cd - >/dev/null
    fi
}

# This is a bit of a mess since we handle both old identity-devops-private
# style config and new module-style config. Once we deprecate the former, we can
# simplify the argument parsing dramatically.
ENVIRONMENT_OR_TF_DIR=$1; shift

if [ -d "terraform/$ENVIRONMENT_OR_TF_DIR" ]; then
    # assume new module-style config if first arg is a directory that exists
    MODULE_STYLE=1

    ENVIRONMENT_OR_TF_DIR="${ENVIRONMENT_OR_TF_DIR%/}" # strip off trailing /

    # split input on '/'
    IFS='/' read -ra parts <<< "$ENVIRONMENT_OR_TF_DIR"

    # Turn "./foo/bar" into "foo/bar"
    if [ "${parts[0]-}" = "." ]; then
        parts=("${parts[@]:1}")
    fi

    if [ "${#parts[@]}" -ne 2 ]; then
        echo_red >&2 "Error: could not parse first argument as TF_DIR."
        echo_red >&2
        echo_red >&2 "First arg is a directory, so I'm assuming it is a new"
        echo_red >&2 "module-style terraform dir. This format is expected to"
        echo_red >&2 "contain two '/'-separated parts."
        echo_red >&2
        echo_red >&2 "Expected format: '<TF_DIR>/<ENV>/'"
        echo_red >&2 "Received:        '$ENVIRONMENT_OR_TF_DIR'"
        exit 2
    fi

    TF_DIR="${parts[0]}"
    ENVIRONMENT="${parts[1]}"
    TF_DIR_FULL="${parts[0]}/${parts[1]}"

    echo_blue >&2 "TF_DIR: $TF_DIR (style: module vars)"
    echo_blue >&2 "ENVIRONMENT: $ENVIRONMENT"

    module_style_check_required_files "$ENVIRONMENT_OR_TF_DIR"
else
    # otherwise use traditional identity-devops-private style
    MODULE_STYLE=

    # environment is first arg
    ENVIRONMENT="$ENVIRONMENT_OR_TF_DIR"

    # tf_dir is second arg
    TF_DIR=$1; shift
    TF_DIR="${TF_DIR%/}" # strip off trailing /
    TF_DIR_FULL="$TF_DIR"

    echo_blue >&2 "TF_DIR: $TF_DIR (style: identity-devops-private vars)"
    echo_blue >&2 "ENVIRONMENT: $ENVIRONMENT"
fi

# If we're loading the terraform remote state, then override our default
# argument parsing. (Yeah, this is ugly.)
if [ -n "$IMPORT_REMOTE_STATE" ]; then
    if [ $# -gt 0 ]; then
        usage
        echo_red "Cannot pass arguments when --import-remote-state is set"
        exit 1
    fi

    echo_blue "Importing TF remote state, as requested..."

    TF_CMD=("command-should-not-be-reached")
else

    # Consume all remaining arguments as Terraform command

    if [ $# -eq 0 ]; then
        usage
        exit 1
    fi

    TF_CMD=("$@")

fi

case "$TF_DIR" in
    cloudtrail)
        # These configurations apply account wide, so set the environment to the
        # account ID.
        #
        # https://stackoverflow.com/a/33791322
        if [ "$ENVIRONMENT" != "global" ]; then
            echo_red >&2 "$TF_DIR applies to the whole AWS account!"
            echo_red >&2 "For safety, pass 'global' as the environment name"
            die "You provided '$ENVIRONMENT'"
        fi

        ENVIRONMENT="account_global_$(run aws sts get-caller-identity --output text --query 'Account')"
        echo >&2 "Forcing environment name to be $ENVIRONMENT since $TF_DIR is account wide configuration"
        ;;
    */?*)
        echo_red >&2 "\$TF_DIR cannot contain slashes, must be at top level"
        die "You provided '$TF_DIR'"
        ;;
esac

check_release_versioning() {
    local strict_check rev_name
    echo >&2 "DEPLOY: Checking whether environment versioning is recommended"
    strict_check="${STRICT_ENVIRONMENT-}"
    [ -z "$strict_check" ] && return

    # Prevent tf_create / tf_destroy from being run on strict envs
    EXTRA_ENV=

    # Instead of requiring stages/prod, stages/sms-prod, etc we squeeze
    # like-environments together.
    if [[ "${ENVIRONMENT}" =~ 'prod' ]] && [[ ! "${ENVIRONMENT}" =~ 'gitlab' ]] ; then
        ENVIRONMENT_CLASS='prod'
    else
        ENVIRONMENT_CLASS=$(echo $ENVIRONMENT | sed -e 's/^.*-//')
    fi

    rev_name="$(git rev-parse --abbrev-ref HEAD)"
    # Reduce name - Accounts like sms-prod and tooling-prod all use stages/prod
    # make sure we're on stages/$ENVIRONMENT_CLASS
    if [ "$rev_name" != "stages/$ENVIRONMENT_CLASS" ]; then
        echo_yellow >&2 "
warning: Current git branch is not the expected stages/$ENVIRONMENT_CLASS

Environment: $ENVIRONMENT
Expected branch: stages/$ENVIRONMENT_CLASS
Actual branch:   $rev_name
"

        # check is fatal for strict environments
        if [ "$strict_check" == 1 ] && [ -z "${DEPLOY_WEIRD_BRANCH-}" ]; then
            echo_red >&2 "Error: Strict environment. Branch name must be stages/$ENVIRONMENT_CLASS"
            echo_red >&2 "(set DEPLOY_WEIRD_BRANCH=1 to skip this check in current environment)"
            return 2
        fi
    else
        # make sure local stages/<env> is the same as origin/stages/<env>

        # fetch latest from remote
        if ! run git fetch "$ORIGIN_REMOTE_NAME"; then
            echo_yellow >&2 "git fetch failed"
        fi

        local local_ref origin_ref
        local_ref="$(git rev-parse "stages/$ENVIRONMENT_CLASS")"
        origin_ref="$(git rev-parse "$ORIGIN_REMOTE_NAME/stages/$ENVIRONMENT_CLASS")"
        if [ "$local_ref" != "$origin_ref" ]; then

            echo_yellow >&2 "
Warning: Local stages branch differs from origin stages branch!
Maybe you need to git push?

stages/$ENVIRONMENT_CLASS:        $local_ref
$ORIGIN_REMOTE_NAME/stages/$ENVIRONMENT_CLASS: $origin_ref

You can also set ORIGIN_REMOTE_NAME if your primary git remote is named
something other than 'origin'.
"

            # check is fatal for strict environments
            if [ -n "$strict_check" ] && [ -z "${DEPLOY_WEIRD_BRANCH-}" ]; then
                echo_red >&2 "error: local and remote stages branches differ"
                echo_red >&2 "set DEPLOY_WEIRD_BRANCH=1 to skip this check"
                return 3
            fi
        fi
    fi


    if [ -n "$strict_check" ]; then
        if [[ ( $(cat VERSION.txt) == *pre* ||
                ! "$(git log -n 1 --pretty=format:'%d')" =~ tag: ) ]]
        then
            echo_yellow >&2 "

###############################################################################
#                              INFORMATIONAL                                  #
###############################################################################

We would like to start using tagged release versions that we carry through
environments for user-facing environments.

The $ENVIRONMENT environment ideally should be deployed from a tagged,
non-prerelease version because it is one of the environments officially
supported by the devops team for client use.

Please consider running \`rake release\` to edit VERSION.txt and create a
tagged release.

See https://github.com/18F/identity-devops/tree/main/doc/process/releases.md
for more details about our release tools.

The current version in VERSION.txt is: $(cat VERSION.txt)

"
        fi
    fi
}

# Verify that the account ID expected from env vars matches the actual AWS
# account that we connect to when running AWS commands. This isn't as useful
# for newer module-style terraform directories, which can independently specify
# 'allowed_account_ids = ["01234..."]' in their main.tf files.
check_account_id() {
    real_account_id="$(run aws sts get-caller-identity --output text --query 'Account')"
    if [ "$real_account_id" != "$aws_account_id" ]; then
        echo_red "Account ID from environment does not match actual account"
        echo_red "From env vars:     $aws_account_id"
        echo_red "Actual account ID: $real_account_id"
        echo_red "Are you sure you set AWS_PROFILE / secret key right?"
        die "error: Account ID mismatch"
    fi
}

# Use the newer, massively simpler, module style of keeping env vars in subdirs.
load_env_module_style() {
    local env_vars_file
    env_vars_file="terraform/$TF_DIR/$ENVIRONMENT/env-vars.sh"
    echo >&2 "DEPLOY: Loading module-style env variables from $env_vars_file..."
    # shellcheck source=/dev/null
    . "$env_vars_file"

    if [ -z "${aws_account_id-}" ]; then
        echo_red "Expected to find var \$aws_account_id in env vars file"
        return 3
    fi

    MOVED_TO_TFVARS=

    # verify that current_tf_version is within versions supported
    # by terraform-switch
    check_terraform_version 'KNOWN_TF_VERSIONS' "${KNOWN_TF_VERSIONS[@]}" >&2

    STATE="terraform-${TF_DIR_FULL}.tfstate"
}


# Load and validate environment variables from identity-devops-private using
# bin/deploy/load-env.sh and bin/deploy/get-tfvars-for-env
load_env_devops_private_style() {
    local strict_check
    echo >&2 "DEPLOY: Loading shared-style environment variables..."
    verify_not_module_style
    . bin/deploy/load-env.sh "$ENVIRONMENT"

    if [ -z "${TF_VAR_account_id-}" ]; then
        echo_red >&2 "Expected to find TF_VAR_account_id in private env"
        return 3
    fi

    aws_account_id="$TF_VAR_account_id"

    if [ -n "$MOVED_TO_TFVARS" ]; then
        echo >&2 "Looks like this environment has switched to using .tfvars files"
        strict_check="${STRICT_ENVIRONMENT-}"
        [[ -z "${strict_check}" ]] || EXTRA_ENV=
        # read a list of .tfvars files printed by get-tfvars-for-env
        tfvars_names="$(bin/deploy/get-tfvars-for-env "$aws_account_id" "$ENVIRONMENT" "$EXTRA_ENV")"

        # render an array prefixing each filename with -var-file
        # in bash 4 we could use mapfile instead
        tf_vars_opts=()
        while IFS= read -r line; do
            tf_vars_opts+=( "-var-file" "$line" )
        done <<< "$tfvars_names"
    fi

    # Check that current version of terraform is supported by our environment. This
    # array should be set in the environment-specific variables.
    check_terraform_version 'ID_SUPPORTED_TERRAFORM_VERSIONS' "${ID_SUPPORTED_TERRAFORM_VERSIONS[@]}" >&2

    # ALSO verify that current_tf_version is within versions supported
    # by terraform-switch, to prevent forcing version ratcheting due to
    # modified state snapshots
    check_terraform_version 'KNOWN_TF_VERSIONS' "${KNOWN_TF_VERSIONS[@]}" >&2


    STATE="terraform-${TF_DIR}/terraform-${TF_VAR_env_name}.tfstate"
}

import_remote_state_resources() {
    local addr1 addr2 cmd1 cmd2

    # Import the terraform remote state S3 bucket and remote state lock table.
    # The commands will end up looking something like:
    # terraform import $prefix.tf-state.aws_s3_bucket.tf-state $TERRAFORM_STATE_BUCKET
    # terraform import \
    #     module.main.module.tf-state.aws_dynamodb_table.tf-lock-table $
    # terraform import module.... ID_state_lock_table

    if [ -z "${ID_state_module_prefix-}" ]; then
        echo_red "error: ID_state_module_prefix is unset"
        echo_red "This must be set to the terraform address of the module"
        echo_red "where the remote state resources should be imported."
        echo_red "For example, 'module.main.module.tf-state'"
        return 5
    fi

    # Prepare commands for execution and prompt for confirmation / edits
    while true; do
        addr1="$ID_state_module_prefix.aws_s3_bucket.tf-state"
        addr2="$ID_state_module_prefix.aws_dynamodb_table.tf-lock-table"

        cmd1=(terraform import "$addr1" "$TERRAFORM_STATE_BUCKET")
        cmd2=(terraform import "$addr2" "$ID_state_lock_table")

        echo "About to run these terraform commands:"
        echo "    + ${cmd1[*]}"
        echo "    + ${cmd2[*]}"
        if prompt_yn "Is this correct? (Answer N to edit)"; then
            break
        fi

        read -rp "Terraform remote state S3 bucket name: " TERRAFORM_STATE_BUCKET
        read -rp "Terraform remote state lock table name: " ID_state_lock_table
    done

    # Send output from these commands to the real stdout (FD 3)
    run "${cmd1[@]}" >&3
    run "${cmd2[@]}" >&3

    echo_blue "Finished importing terraform remote state resources"
}

add_tfvars_to_tf_cmd() {
    # If we are using variables from .tfvars files, splice in the -var-file options
    # after the first element in TF_CMD, which will be the terraform command like
    # plan/apply etc. (Only do this for terraform subcommands that accept
    # -var-file. For terraform apply you can't pass vars if you also pass a plan
    # file, so allow the caller to disable loading vars with ID_SKIP_LOADING_VARS.)
    if [ -n "$MOVED_TO_TFVARS" ] && [ -z "${ID_SKIP_LOADING_VARS-}" ]; then
        tf_subcommand="${TF_CMD[0]-}"

        # these are the subcommands that accept -var-file
        case "$tf_subcommand" in
            apply|destroy|import|plan|refresh)
                TF_CMD=(
                    "$tf_subcommand" "${tf_vars_opts[@]}" "${TF_CMD[@]:1}"
                )
                ;;
        esac
    fi
}

# Be sure ruby is working and bundler is setup since some terraform modules
# rely on erb templates and ruby to be working.
run bundle check >&2

if [ -n "$MODULE_STYLE" ]; then
    style_description="module, separate subdirectory style"
    load_env_module_style
else
    style_description="shared, identity-devops-private, symlink style"
    MOVED_TO_TFVARS=1
    load_env_devops_private_style
fi

check_release_versioning

check_branch_age

echo_blue >&2 "Finished loading environment variables"
echo_blue >&2 "The .terraform directory for $TF_DIR is: $style_description"

check_account_id

echo >&2 "Using state file: $STATE"

echo >&2 "Ensuring terraform/${TF_DIR_FULL} is a terraform directory"
if [ ! -f "terraform/${TF_DIR_FULL}/main.tf" ] ; then
    echo_red "deploy: not found: 'terraform/${TF_DIR_FULL}/main.tf'"
    echo_red "Are you sure 'terraform/${TF_DIR_FULL}' is a terraform project folder?"
    echo_red "Known examples include terraform/app, etc."
    echo_red "Did you specify your username? This script no longer takes a "
    echo_red "username argument."
    die "error: Could not find terraform files"
fi

if [ -z "${TERRAFORM_STATE_BUCKET:=}" ] ; then
    die "You must set the TERRAFORM_STATE_BUCKET environment variable.  \
This should contain the name of the s3 bucket used to store terraform state for this run."
fi

if [ -z "${TERRAFORM_STATE_BUCKET_REGION:=}" ] ; then
    die "You must set the TERRAFORM_STATE_BUCKET_REGION environment variable.  \
This should contain the region of the s3 bucket used to store terraform state for this run."
fi

if [ -z "${ID_state_lock_table-}" ]; then
    die "Must set ID_state_lock_table to dynamodb terraform state locking table"
fi

if [ -n "$MODULE_STYLE" ]; then
    style_option="--module-style"
else
    style_option="--shared-style"
fi

if [ "${LOCAL_LOCKFILE}" == 1 ] ; then
    if [ -L "terraform/${TF_DIR_FULL}/.terraform.lock.hcl" ] ; then
        echo_yellow >&2 "A symlink to the repo-root provider lock file already exists in ${TF_DIR_FULL}"
        if prompt_yn "Create a new .terraform.lock.hcl file?"; then
            rm "terraform/${TF_DIR_FULL}/.terraform.lock.hcl"
        else
            LOCAL_LOCKFILE=0
        fi
    fi
fi

fix_local_lockfile

echo >&2 "Configuring state bucket $TERRAFORM_STATE_BUCKET with path $STATE"

run bin/deploy/configure_state_bucket.sh "$style_option" "$TERRAFORM_STATE_BUCKET" \
    "$STATE" "$TF_DIR_FULL" "$TERRAFORM_STATE_BUCKET_REGION" "$ID_state_lock_table" "$LOCAL_LOCKFILE"

echo >&2 "+ cd terraform/$TF_DIR_FULL"
cd "terraform/$TF_DIR_FULL"

cat >&2 <<EOF
########################################
#
# Deploy environment:
#     TF_DIR: $TF_DIR
#     ENVIRONMENT: $ENVIRONMENT
#
########################################

EOF

echo_blue >&2 "Running terraform get"
run terraform get >&2

if [[ "${TF_CMD[0]}" = "shell" ]]; then
    set +e
    echo_yellow "Starting terraform shell - Press enter without a command to exit"
    while true; do
        echo -n "terraform > "
        read -a TF_CMD
        [ -z ${TF_CMD+x} ] && break
        add_tfvars_to_tf_cmd
        run terraform "${TF_CMD[@]}" >&3
    done
    echo_yellow "Exiting terraform shell"
    exit
fi

if [ -n "$IMPORT_REMOTE_STATE" ]; then
    # Import terraform remote state rather than running any terraform commands
    import_remote_state_resources
    echo_blue "All done"
    exit
fi

echo >&2
echo_blue >&2 "Running terraform..."

# Run main terraform command. This is the only command that should print to
# stdout (reassigned to FD 3)
add_tfvars_to_tf_cmd
if run terraform "${TF_CMD[@]}" >&3 ; then
    DEPLOY_FAIL='false'
else
    DEPLOY_FAIL='true'
fi

# if running apply or destroy, notify success/fail in Slack
if [[ "${TF_CMD[0]}" =~ ^(apply|destroy)$ ]] && [[ -z ${TEST_ONLY} ]] ; then
    cd "${repo_root_before_cd}"
    define TF_VERSION_INFO <<EOM
main_commit=$(git log -n 1 --pretty=format:"%H")
main_branch=$(git rev-parse --abbrev-ref HEAD)
main_version=$(cat VERSION.txt)
deployed_by=$(run aws sts get-caller-identity --output text --query Arn | awk -F\/ '{print $3}')
EOM

    if [ -n "$MODULE_STYLE" ] ; then
        TF_DEPLOY_INFO=$(echo "${TF_VERSION_INFO}" | sed '$!s/$/\\n/' | tr -d '\n')
        TF_PATH=${TF_DIR_FULL}
    else
        TF_DEPLOY_INFO=$(bin/deploy/get-version-info.sh "${ENVIRONMENT}" 2>/dev/null | sed '$!s/$/\\n/' | tr -d '\n')
        TF_PATH="${TF_DIR_FULL}/${ENVIRONMENT}"
        MODULE_STYLE=0
    fi

    TF_SLACK_EMOJI=':terraform:'
    TF_SLACK_USER='Terraform Deployments'
    if [ "$DEPLOY_FAIL" == 'true' ] ; then
        TF_SLACK_ICON=':large_red_square:'
        SLACK_PRETEXT="tf-deploy *FAILED* for \`${TF_PATH}\` !"
        SLACK_MESSAGE="Please investigate!"
    else
        TF_SLACK_ICON=':large_green_square:'
        SLACK_PRETEXT="tf-deploy *SUCCESSFUL* for \`${TF_PATH}\` !"
        SLACK_MESSAGE="\`\`\`${TF_DEPLOY_INFO}\`\`\`"
    fi

    slack_notify \
        -n "${real_account_id}" \
        -t "${ENVIRONMENT}" \
        -r "${TERRAFORM_STATE_BUCKET_REGION}" \
        -i "${TF_SLACK_ICON}" \
        -u "${TF_SLACK_USER}" \
        -e "${TF_SLACK_EMOJI}" \
        -p "${SLACK_PRETEXT}" \
        -m "${SLACK_MESSAGE}" \
        -y "${MODULE_STYLE}" \
        -c "${TERRAFORM_SLACK_CHANNEL}"
fi

if [ "$DEPLOY_FAIL" == 'true' ] ; then exit 1 ; fi

