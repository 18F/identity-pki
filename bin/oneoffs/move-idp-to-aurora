#!/bin/bash

#### Promote IdP AuroraDB cluster to standalone and (if desired) spin down RDS DB

set -euo pipefail

BASEPATH="$(dirname "$0")/.."
. "${BASEPATH}/lib/common.sh"
. "${BASEPATH}/lib/sandbox-lib.sh"

trap rm_files EXIT

usage() {
  cat >&2 << EOM

Usage: ${0} [-p1u2x3[rcdy]h] [TF_ENV] (will use \$GSA_USERNAME if not specified)

Flags (will run 1 + 2 if not specified):
  -p / -1 : Promote IdP AuroraDB replica cluster to a regional/standalone cluster
  -u / -2 : Update application.yml files for idp/pivcac with cluster addresses
  -x / -3 : Remove protection from RDS DB and destroy it + related resources
            (NOT run by default, unless specified)
  -h      : Detailed help

EOM
}

help_me() {
  cat >&2 << EOM

Given a sandbox environment (\$GSA_USERNAME if not specified), with an RDS instance
as the main IdP DB, and an AuroraDB cluster replicating said RDS instance:

1. Promotes the AuroraDB cluster to a standalone/regional cluster
2. Pulls down the application.yml files for both the idp and pivcac apps,
   updates the database_host / database_read_replica_host entries with the
   AuroraDB cluster write/read endpoint addresses, and prompts to recycle
   the corresponding host(s) in the environment
3. (OPTIONALLY) Removes protection from the source RDS DB, and then remove it
   (and all associated resources) via \`terraform apply\`, with the
   idp_use_rds variable set to \`false\` to do so.

EOM
  usage
  exit 0
}

rm_files() {
  replace_db_files
  if [[ -f "${YAML}" ]] && [[ "${TODO[@]:-}" =~ "${TASKS[1]}" ]] ; then
    rm "${YAML}"
  fi
}

1_promote_cluster() {
  if [[ ! -z $(ave aws rds describe-db-clusters --db-cluster-identifier ${CLUSTER} |
        jq -r '.DBClusters[].ReplicationSourceIdentifier|select (.!=null)') ]] ; then
    ave aws rds wait db-cluster-available --db-cluster-identifier "${CLUSTER}"
    ave aws rds promote-read-replica-db-cluster \
      --db-cluster-identifier "${CLUSTER}"
    sleep 1
    ave aws rds wait db-cluster-available --db-cluster-identifier "${CLUSTER}"
  else
    echo_yellow "Cluster ${CLUSTER} is already a regional cluster; skipping."
  fi
}

2_update_yaml() {
  for APP in pivcac idp ; do
    ave ${BASEPATH}/app-s3-secret --env ${TF_ENV} --app ${APP} --download "${YAML}"
    if [[ ! $(grep "${CLUSTER}" "${YAML}") ]] ; then
      run sed -i '' -E "s/${RDS_INSTANCE}\./${CLUSTER}\.cluster-/" "${YAML}"
      run sed -i '' -E "s/${RDS_REPLICA}\./${CLUSTER}\.cluster-ro-/" "${YAML}"
      ave ${BASEPATH}/app-s3-secret --env ${TF_ENV} --app ${APP} --upload "${YAML}"
      echo_cyan "application.yml updated!"
      if prompt_yn "Recycle ${APP} hosts now to pull in config changes?" ; then
        ave ${BASEPATH}/asg-recycle -q ${TF_ENV} ${APP}
      fi
    else
      echo_yellow "application.yml values already point to ${CLUSTER}; skipping."
    fi
    rm "${YAML}"
  done
}

3_destroy_rds_instance() {
  if [[ ! $(ave aws rds describe-db-instances \
          --db-instance-identifier $RDS_INSTANCE) ]] ; then
    echo_yellow "RDS instance ${RDS_INSTANCE} not found; nothing to terminate."
  else
    local IDP_RESOURCES=(
      "aws_db_instance.idp[0]"
      "aws_route53_record.idp-postgres[0]"
      "module.idp_cloudwatch_rds[0]"
      "module.rds_dashboard_idp[0]"
    )
    local TF_ARGS=( "${IDP_RESOURCES[@]/#/-target=}" )
    
    DBS_TO_REMOVE=('app/idp')
    remove_db_protection_in_state
    
    for FLAG in '' ' -m' ; do
      ave ${BASEPATH}/tf-deploy -t${FLAG} ${TF_ENV} app apply \
        -auto-approve "${TF_ARGS[@]:-}"
      sleep 1
    done
    replace_db_files
  fi
}

TASKS=(
  "1_promote_cluster"
  "2_update_yaml"
  "3_destroy_rds_instance"
)

while getopts p1u2x3r:c:d:y:h opt
do
  case $opt in
    p|1) TODO+=("${TASKS[0]}")        ;;
    u|2) TODO+=("${TASKS[1]}")        ;;
    x|3) TODO+=("${TASKS[2]}")        ;;
    h) help_me                        ;;
    *) usage && exit 1                ;;
  esac
done
shift $((OPTIND-1))

initialize ${1:-}

YAML='update-db.yml'
RDS_INSTANCE="login-${TF_ENV}-idp"
RDS_REPLICA="${TF_ENV}-idp-replica"
CLUSTER="login-${TF_ENV}-idp-aurora-us-west-2"

if [[ -z ${TODO-} ]] ; then
  for i in 0 1 ; do 
    TODO+=("${TASKS[$i]}")
  done
fi

run_tasks
