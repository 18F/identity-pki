#!/usr/bin/env ruby

require 'bundler/setup'

require 'aws-sdk'
require 'subprocess'

Aws.config.update({
  region: ENV.fetch('AWS_REGION', 'us-west-2'),
})

class Error < StandardError; end
class ManyFound < Error; end
class NotFound < Error; end

DOMAIN = '.login.gov'

JUMPHOST_PAT = '*jumphost-*'

# Find a jumphost in the same VPC as instance_obj.
def find_jumphost_for_instance(instance_obj)
  vpc_id = instance_obj.vpc_id

  find_any_instance([
    {name: 'tag:Name', values: [JUMPHOST_PAT]},
    {name: 'instance-state-name', values: ['running']},
    {name: 'vpc-id', values: [vpc_id]},
  ])
end

def name_tag_for_instance(instance)
  instance.tags.find {|t| t.key == 'Name'}.value
end

def get_ssh_instance_cmdline(instance_obj, username, command: nil, port: 22, pkcs11_lib: nil, **opts)
  name_tag = name_tag_for_instance(instance_obj)

  if name_tag.include?('jumphost')
    use_jumphost = false
  else
    use_jumphost = true
  end

  cmd = ['ssh', '-l', username]
  cmd += ['-o', 'stricthostkeychecking=no'] # TODO
  cmd += ['-p', port.to_s]

  if pkcs11_lib
    cmd += ['-I', pkcs11_lib]
  end

  hostkey_alias = instance_obj.instance_id + DOMAIN

  if use_jumphost
    jumphost = find_jumphost_for_instance(instance_obj)
    jumphost_ip = jumphost.public_ip_address

    private_ip = instance_obj.private_ip_address

    host = hostkey_alias

    proxycommand = "ssh -W #{private_ip}:#{port}"
    proxycommand << " -I #{pkcs11_lib}" if pkcs11_lib
    proxycommand << " #{username}@#{jumphost_ip}"

    cmd += ['-o', "ProxyCommand=#{proxycommand}"]
  else
    host = instance_obj.public_ip_address
    cmd += ['-o', "HostKeyAlias=#{hostkey_alias}"]
  end

  cmd << host

  cmd << command if command

  cmd
end

def ssh_multi_instances(instances, username, opts)
  log_info("ssh_multi_instances: #{instances.map(&:instance_id).inspect}")
  instances.map { |i|
    Thread.new { ssh_instance(i, username, exec: false, **opts) }
  }.map(&:join)
end

def log_info(message)
  puts message
end

def ssh_instance(instance_obj, username, opts={})
  log_info("ssh_instance #{instance_obj.instance_id}")

  cmd = get_ssh_instance_cmdline(instance_obj, username, **opts)

  if opts[:command] && !opts.include?(:log_prefix)
    opts[:log_prefix] = true
    opts[:exec] = false
  else
    opts[:exec] ||= true
  end

  tag = "#{name_tag_for_instance(instance_obj)} (#{instance_obj.instance_id})"

  if opts[:exec]
    puts "EXEC: " + cmd.inspect
    exec(*cmd)
  else
    puts 'CMD: ' + cmd.inspect

    Subprocess.check_call(cmd, stdin: Subprocess::PIPE, stdout: Subprocess::PIPE, stderr: Subprocess::STDOUT) do |p|
      p.stdin.close

      while line = p.stdout.gets
        puts tag + ': ' + line
      end
    end
  end
rescue Subprocess::NonZeroExit
  puts "error: ssh failed with #{instance_obj.instance_id}"
  raise
end

def lookup_instance_by_id(instance_id)
  i = Aws::EC2::Instance.new(id: instance_id)
  i.image_id # ensure exists, memoize
  i
end

def find_unique_instance(filters)
  ec2 = Aws::EC2::Resource.new
  instances = ec2.instances(filters: filters).to_a
  if instances.length > 1
    raise ManyFound.new("Found multiple instances: " + instances.inspect)
  end
  if instances.length == 0
    raise NotFound.new("No instances found for filters: #{filters.inspect}")
  end

  instances.first
end

def find_any_instance(filters)
  ec2 = Aws::EC2::Resource.new
  instance = ec2.instances(filters: filters).first
  if instance.nil?
    raise NotFound.new("No instances found for filters: #{filters.inspect}")
  end

  instance
end

def find_instances(filters)
  ec2 = Aws::EC2::Resource.new
  instances = ec2.instances(filters: filters).to_a
  if instances.empty?
    raise NotFound.new("No instances found for filters: #{filters.inspect}")
  end

  instances
end

def lookup_instance_by_name(name_tag)
  filters = [
    {name: 'tag:Name', values: [name_tag]},
    {name: 'instance-state-name', values: ['running']},
  ]
  find_unique_instance(filters)
end

def find_instances_by_name(name_tag)
  filters = [
    {name: 'tag:Name', values: [name_tag]},
    {name: 'instance-state-name', values: ['running']},
  ]
  find_instances(filters)
end

def main(args)
  # TODO this whole main function is a hacky placeholder for testing
  username = ENV.fetch('GSA_USERNAME')

  opts = {}
  ssh_opts = {}

  if ENV['MULTI']
    opts[:multi] = true
    instances = find_instances_by_name(args.fetch(0))
  else
    instance = lookup_instance_by_name(args.fetch(0))
  end

  if !ENV.fetch('PKCS11_LIB', '').empty?
    ssh_opts[:pkcs11_lib] = ENV.fetch('PKCS11_LIB')
  end

  if args[1]
    ssh_opts[:command] = args[1]
  end

  if opts[:multi]
    ssh_multi_instances(instances, username, ssh_opts)
  else
    ssh_instance(instance, username, ssh_opts)
  end
end

if __FILE__ == $0
  main(ARGV)
end
