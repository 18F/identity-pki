#!/bin/bash

#### Build up a sandbox environment from scratch ####

set -euo pipefail

BASEPATH="$(dirname "$0")"
. "${BASEPATH}/lib/common.sh"
. "${BASEPATH}/lib/sandbox-lib.sh"

usage() {
  cat >&2 << EOM

Usage: ${0} [-casdmh] [ENV] (defaults to \$GSA_USERNAME if not specified)

Flags (will run all if no flags specified):
  -c : Clear CloudWatch log groups left over from previous env destroy
  -a : Copy S3 app-secrets v1/application.yml files from dev to ENV
  -s : Copy S3 secrets listed in ./lib/build-keys from dev to ENV
  -d : Run terraform-apply + spin up 1 migration host
  -m : Schedule the ENV-migration ASG to reset to 0 in 15min
  -h : Detailed help

EOM
}

help_me() {
    cat >&2 << EOM
    
Usage: ${0} [-asdiph] [ENV]

Runs all necessary commands to create a full terraform-app environment,
\${TF_ENV}, in the login-sandbox account. Designed to run with no
specified flags/arguments.

The tasks in this script can also be individually executed
using the following flags:

  -c : Clear out and delete any CloudWatch log groups accidentally
       left over from a previous environment purge, if any exist
  -a : Duplicate all v1/application.yml files for \`dev\`,
       within the login-gov.app-secrets bucket, for \${TF_ENV},
       replacing all instances of \`dev\` within with \${TF_ENV} 
  -s : Copy all files listed in ./lib/build-keys from the int/ dir
       within the login-gov.secrets bucket to a \${TF_ENV}/ dir in
       the same bucket
  -d : Run \`terraform apply -auto-approve\` against \${TF_ENV},
       spinning up 1 migration host to run database migrations
       as the environment comes up
  -m : Add a Scheduled Action to the \${TF_ENV}-migration Auto
       Scaling Group, which sets its Desired count back to 0 after
       15 minutes' time (as is done with IDP recycles)
  -h : Displays this help

This script will default to using \${GSA_USERNAME} for the
value of \${TF_ENV}, unless a different one is specified
as a final argument.

EOM
  exit 0
}

1_clear_log_groups() {
  for LOG_GROUP in $(ave aws logs describe-log-groups |
    jq --arg TF "${TF_ENV}" -r '.logGroups[]|
    select(.logGroupName|startswith($TF)).logGroupName') ; do
      ave aws logs delete-log-group \
        --log-group-name ${LOG_GROUP}
  done
}

2_app_secrets() {
  BUCKET="login-gov.app-secrets.${AWS_ACCT_NUM}-${AWS_REGION}"
  for KEY in $(ave aws s3 ls s3://${BUCKET}/${SOURCE_ENV}/ |
      awk '{print $NF}' | tr -d '/') ; do
        ave aws s3 cp s3://${BUCKET}/${SOURCE_ENV}/${KEY}/v1/application.yml - |
          sed -E "s/${SOURCE_ENV}(\.|-)/${TF_ENV}\1/" |
          ave aws s3 cp - s3://${BUCKET}/${TF_ENV}/${KEY}/v1/application.yml >/dev/null
  done
}

3_regular_secrets() {
  BUCKET="login-gov.secrets.${AWS_ACCT_NUM}-${AWS_REGION}"
  for KEY in $(cat bin/lib/build-keys) ; do
      ave aws s3 cp s3://${BUCKET}/${SOURCE_ENV}/${KEY} \
                s3://${BUCKET}/${TF_ENV}/${KEY} >/dev/null
  done
}

4_tf_deploy() {
  ave ${BASEPATH}/tf-deploy -m ${TF_ENV} app apply -auto-approve
  MIGRATION_HOST_BUILT=true
}

5_migration_scaling() {
  while [[ ! ${MIGRATION_HOST_BUILT} ]] ; do
    if [[ $(ave aws autoscaling describe-auto-scaling-groups \
        --auto-scaling-group-name "${TF_ENV}-migration" \
        --query 'AutoScalingGroups[].DesiredCapacity' \
        --output text) == 0 ]] ; then
      ave aws autoscaling set-desired-capacity \
        --auto-scaling-group-name "${TF_ENV}-migration" \
        --desired-capacity 1
    else
      MIGRATION_HOST_BUILT=true
    fi
  done
  ave aws autoscaling put-scheduled-update-group-action \
    --auto-scaling-group-name "${TF_ENV}-migration" \
    --scheduled-action-name "DelayedScaleInOnce.asg-recycle" \
    --start-time "$(date -uj -v+15M '+%Y-%m-%dT%H:%M:%SZ')" \
    --desired-capacity 0
}

TASKS=(
  "1_clear_log_groups"
  "2_app_secrets"
  "3_regular_secrets"
  "4_tf_deploy"
  "5_migration_scaling"
)
TODO=()
while getopts casdmh opt
do
  case $opt in
    c) TODO+=("${TASKS[0]}") ;;
    a) TODO+=("${TASKS[1]}") ;;
    s) TODO+=("${TASKS[2]}") ;;
    d) TODO+=("${TASKS[3]}") ;;
    m) TODO+=("${TASKS[4]}") ;;
    h) help_me               ;;
    *) usage && exit 1       ;;
  esac
done
shift $((OPTIND-1))
initialize ${1:-}

SOURCE_ENV='dev'
MIGRATION_HOST_BUILT=

run_tasks
