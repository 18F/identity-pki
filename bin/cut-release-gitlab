#!/bin/bash

# Cut a new release, create a MR, and add the release to GitLab

set -euo pipefail

. "$(dirname "$0")/lib/common.sh"
. "$(dirname "$0")/lib/gitlab.sh"

usage() {
  cat >&2 <<EOM

Usage: ${0}

Calculates the current, and next, releases, based on the contents of VERSION.txt,
then cuts a new release by:

1. updating VERSION.txt to the new release number ONLY (e.g. pre-325 -> 325)
2. committing this change + adding a version number tag to the commit
3. re-updating VERSION.txt to the post-release number (e.g. 325 -> pre-326)
4. committing THAT change + pushing the commits and tag to origin

Once the tags are pushed to origin, the script will print out a list of all MRs
merged to 'main' since the MR from the previous release, and then will (via glab)
create both a Merge Request and a Release for the version update.

Runs with no arguments. Will automatically check to see if any of the steps above
have already been completed -- WITHOUT having an MR created -- and will fail in case
there already is an MR (merged or not) for the new release.

EOM
}

1_remote_tag() {
  run git push --delete origin "v${NEW_RELEASE}"
}

2_local_tag() {
  run git tag --delete "v${NEW_RELEASE}"
}

3_remote_branch() {
  run git push origin --delete "release/v${NEW_RELEASE}"
}

4_local_branch() {
  run git branch -D "release/v${NEW_RELEASE}"
}

update_version() {
  local RELEASE_VERSION=${1}
  echo "${RELEASE_VERSION}" >VERSION.txt
  git add VERSION.txt

  case "${RELEASE_VERSION}" in
  ${NEW_RELEASE})
    git commit -m "Release version ${NEW_RELEASE}"
    git tag "v${NEW_RELEASE}"
    ;;
  ${POST_RELEASE})
    git commit -m "Post release version ${POST_RELEASE}"
    git push origin release/v${NEW_RELEASE}
    git push origin v${NEW_RELEASE} # push w/remote tags
    ;;
  esac
}

echo
[ $# -gt 0 ] && raise 'Must run without arguments!'

verify_root_repo

declare {OLD_RELEASE_DATE,NEW_VERSION_MR,BREAKING_MRS,REGULAR_MRS}=
MR_LIST=()
TODO=()
TASKS=(
  "1_remote_tag"
  "2_local_tag"
  "3_remote_branch"
  "4_local_branch"
)

# always start from main, with a full pull/fetch rotation for good measure
run git checkout main
run git pull origin main
run git fetch
run git pull origin main
if [[ ! -z $(git log origin/main..main) ]]; then
  echo_red "Local 'main' branch not up to date with remote 'origin/main' branch."
  raise "Bring local branch up to date and try again!"
fi

NEW_RELEASE=$(cat VERSION.txt | sed -E 's/pre\-//')
OLD_RELEASE=$((${NEW_RELEASE} - 1))
POST_RELEASE="pre-$((${NEW_RELEASE} + 1))"

# make sure an MR for NEW_RELEASE doesn't already exist (merged or not)
NEW_VERSION_MR=$(glab mr ls -A --search "Release v${NEW_RELEASE}" -F json |
                jq -r '.[].state' | sort -u)
if [[ ! -z ${NEW_VERSION_MR} ]] && [[ ${NEW_VERSION_MR} != 'closed' ]]; then
  echo_red "Existing MR for Release v${NEW_RELEASE} found with status '${NEW_VERSION_MR}'."
  raise "Verify release number in VERSION.txt and try again!"
fi

# in case this script was interrupted, and the branch/tag already exists (locally
# and/or remotely), delete them and then start over
echo_cyan "Verifying existing git branches/tags..."
if [[ $(git branch | grep "release/v${NEW_RELEASE}") ]]; then
  echo_yellow "Local branch 'release/v${NEW_RELEASE}' already exists."
  TODO+=("${TASKS[3]}")
fi
if [[ $(git branch -r | grep "v${NEW_RELEASE}") ]]; then
  echo_yellow "Remote branch 'release/v${NEW_RELEASE}' already exists."
  TODO+=("${TASKS[2]}")
fi
if [[ $(git tag | grep "v${NEW_RELEASE}") ]]; then
  echo_yellow "Local tag 'v${NEW_RELEASE}' already exists."
  TODO+=("${TASKS[1]}")
fi
if [[ $(git ls-remote --tags origin | grep "v${NEW_RELEASE}") ]]; then
  echo_yellow "Remote tag 'v${NEW_RELEASE}' already exists."
  TODO+=("${TASKS[0]}")
fi

if [[ ! -z ${TODO-} ]]; then
  if prompt_yn "Remove unmerged/unpushed branch/tag and restart release?"; then
    run_tasks
  else
    raise "Remove/fix branch(es)/tag(s) before re-running script!"
  fi
fi

# get data on last 1000 MRs: id, title, and date merged.
echo_cyan "Getting merge request (MR) data..."
for PAGE_NUM in $(seq 1 10) ; do
  MR_LIST+=($(glab mr list -t main -M -P 100 -F json -p ${PAGE_NUM} |
            jq '.[]|{id:.iid,title:.title,date:.merged_at}'))
done

# find the MR of the last release. keep incrementing the number of MRs
# to check (by page number x 100) if not found, and bail out at 200 MRs
echo_cyan "Finding MR for previous release 'v${OLD_RELEASE}'..."
while [[ -z ${OLD_RELEASE_DATE} ]]; do
  OLD_RELEASE_DATE=$(echo "${MR_LIST[@]}" |
    jq -r --arg OLD_RELEASE "Release v${OLD_RELEASE}" \
    '.|select(.title == $OLD_RELEASE).date')
  if [[ ${PAGE_NUM} -lt 20 ]]; then
    ((PAGE_NUM++))
    MR_LIST+=($(glab mr list -t main -M -P 100 -F json -p ${PAGE_NUM} |
            jq '.[]|{id:.iid,title:.title,date:.merged_at}'))
  else
    echo_red "Previous release 'v${OLD_RELEASE}' not found in the last $((${PAGE_NUM} * 10)) MRs."
    raise "Verify release number in VERSION.txt and try again"
  fi
done

# sort list of MRs by .date (merged_at), separate out anything marked '(BREAKING)'
RELEASE_MRS=$(echo "${MR_LIST[@]}" | jq -s '.|sort_by(.date)|reverse' |
  jq -r --arg RELEASE_DATE "$OLD_RELEASE_DATE" \
  '.[]|select(.date > $RELEASE_DATE)|"- !" + (.id|tostring) + "  " + .title')
REGULAR_MRS=$(echo "${RELEASE_MRS}" | grep -v BREAKING) || true
if [[ $(echo "${RELEASE_MRS}" | grep BREAKING) ]]; then
  BREAKING_MRS="
BREAKING CHANGES:
$(echo "${RELEASE_MRS}" | grep BREAKING | sed -E 's/\(BREAKING\)| \| BREAKING//g')"
  if [[ ! -z ${REGULAR_MRS:-} ]]; then
    REGULAR_MRS="
REGULAR CHANGES:
$(echo "${REGULAR_MRS}")"
  fi
fi

RAW_DESCRIPTION="$(
  cat <<EOF
$(echo "${BREAKING_MRS}" | sed -E 's/^(- \#[0-9]+) .+$/\1/g')
$(echo "${REGULAR_MRS}" | sed -E 's/^(- \#[0-9]+) .+$/\1/g')
EOF
)"
GLAB_DESCRIPTION="$(sanitize_glab_mr_description "${RAW_DESCRIPTION}")"
GL_REV_GROUP="devops"

# print out the MR list to the console, just for a final sanity check
echo "${RAW_DESCRIPTION}"

# with MR_LIST figured out, and branch clear to create, do the thing
git checkout -b "release/v${NEW_RELEASE}"
echo && echo_cyan "Cutting release: ${OLD_RELEASE} -> ${NEW_RELEASE}"
update_version ${NEW_RELEASE}
echo && echo_cyan "Setting version to ${POST_RELEASE} post-release."
update_version ${POST_RELEASE}
echo

run glab mr create --title "Release v${NEW_RELEASE}" \
  --description "${GLAB_DESCRIPTION}" \
  --assignee "$(get_glab_assignee)" \
  --reviewer "$(get_reviewer_list_without_assignee)"

run glab release create v${NEW_RELEASE} -N "$(
  cat <<EOF
${BREAKING_MRS}
${REGULAR_MRS}
EOF
)"
