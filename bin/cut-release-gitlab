#!/bin/bash

# Cut a new release, create a MR, and add the release to GitLab

set -euo pipefail

. "$(dirname "$0")/lib/common.sh"

usage() {
    cat >&2 << EOM

Usage: ${0}

Calculates the current, and next, releases, based on the contents of VERSION.txt,
then cuts a new release by:

1. updating VERSION.txt to the new release number ONLY (e.g. pre-325 -> 325)
2. committing this change + adding a version number tag to the commit
3. re-updating VERSION.txt to the post-release number (e.g. 325 -> pre-326)
4. committing THAT change + pushing the commits and tag to origin

Once the tags are pushed to origin, the script will print out a list of all MRs
merged to 'main' since the MR from the previous release, and then will (via glab)
create both a Merge Request and a Release for the version update.

Runs with no arguments. Will automatically check to see if any of the steps above
have already been completed -- WITHOUT having an MR created -- and will fail in case
there already is an MR (merged or not) for the new release.

EOM
}

1_remote_tag() {
  run git push --delete origin "v${NEW_RELEASE}"
}

2_local_tag() {
  run git tag --delete "v${NEW_RELEASE}"
}

3_remote_branch() {
  run git push origin --delete "release/v${NEW_RELEASE}"
}

4_local_branch() {
  run git branch -D "release/v${NEW_RELEASE}"
}

update_version() {
  local RELEASE_VERSION=${1}
  echo "${RELEASE_VERSION}" > VERSION.txt
  git add VERSION.txt

  case "${RELEASE_VERSION}" in
    ${NEW_RELEASE})
      git commit -m "Release version ${NEW_RELEASE}"
      git tag "v${NEW_RELEASE}"
    ;;
    ${POST_RELEASE})
      git commit -m "Post release version ${POST_RELEASE}"
      git push origin release/v${NEW_RELEASE}
      git push origin v${NEW_RELEASE} # push w/remote tags
    ;;
  esac  
}

echo
[ $# -gt 0 ] && raise 'Must run without arguments!'
verify_root_repo

if [[ ! $(command -v glab) ]] ; then
  brew install glab || raise "glab not installed!"
fi

declare {OLD_VERSION_MR,NEW_VERSION_MR,BREAKING_MRS,REGULAR_MRS}=
TODO=()
TASKS=(
  "1_remote_tag"
  "2_local_tag"
  "3_remote_branch"
  "4_local_branch"
)

# always start from main
run git checkout main
if [[ ! -z $(git log origin/main..main) ]] ; then
  echo_red "Local 'main' branch not up to date with remote 'origin/main' branch."
  raise "Bring local branch up to date and try again!"
fi

NEW_RELEASE=$(cat VERSION.txt | sed -E 's/pre\-//')
OLD_RELEASE=$((${NEW_RELEASE}-1))
POST_RELEASE="pre-$((${NEW_RELEASE}+1))"

# make sure an MR for NEW_RELEASE doesn't already exist (merged or not)
NEW_VERSION_MR=$(glab mr ls -A --search "Release v${NEW_RELEASE}" |                 
    sed -E 's/^\!/\- \!/;s/\(main\).+//' | awk '{$3=""; print $0}' | tail -n +2)
if [[ $(echo ${NEW_VERSION_MR} | grep ${NEW_RELEASE}) ]] ; then
  echo_red "An MR for Release v${NEW_RELEASE} already exists:"
  echo_red "${NEW_VERSION_MR}"
  raise "Verify release number in VERSION.txt and try again!"
fi

# in case this script was interrupted, and the branch/tag already exists (locally
# and/or remotely), delete them and then start over
echo_cyan "Verifying existing git branches/tags..."
if [[ $(git branch | grep "release/v${NEW_RELEASE}") ]] ; then
  echo_yellow "Local branch 'release/v${NEW_RELEASE}' already exists."
  TODO+=("${TASKS[3]}")
fi
if [[ $(git branch -r | grep "v${NEW_RELEASE}") ]] ; then
  echo_yellow "Remote branch 'release/v${NEW_RELEASE}' already exists."
  TODO+=("${TASKS[2]}")
fi
if [[ $(git tag | grep "v${NEW_RELEASE}") ]] ; then
  echo_yellow "Local tag 'v${NEW_RELEASE}' already exists."
  TODO+=("${TASKS[1]}")
fi
if [[ $(git ls-remote --tags origin | grep "v${NEW_RELEASE}") ]] ; then
  echo_yellow "Remote tag 'v${NEW_RELEASE}' already exists."
  TODO+=("${TASKS[0]}")
fi

if [[ ! -z ${TODO-} ]] ; then
  if prompt_yn "Remove unmerged/unpushed branch/tag and restart release?" ; then
    run_tasks
  else
    raise "Remove/fix branch(es)/tag(s) before re-running script!"
  fi
fi

exit
# get MR of previous release; exit if there isn't one in the last 100 MRs
echo_cyan "Finding MR for previous release 'v${OLD_RELEASE}'..."
MR_NUM=25
while [[ -z ${OLD_VERSION_MR} ]] ; do
  MR_LIST=$(glab mr list --merged --target-branch=main --per-page ${MR_NUM} |
    sed -E 's/^\!/\- \!/;s/\(main\).+//' | awk '{$3=""; print $0}' | tail -n +2)
  
  OLD_VERSION_MR=$(echo "${MR_LIST}" | grep "Release v${OLD_RELEASE}" | tr -d '\n')
  if [[ ${MR_NUM} -lt 100 ]] ; then
    ((MR_NUM+=25))
  else
    echo_red "Previous release 'v${OLD_RELEASE}' was not found in the last ${MR_NUM} MRs."
    raise "Verify release number in VERSION.txt and try again"
  fi
done

# get all MRs since last release; separate out anything marked '(BREAKING)'
RELEASE_MRS=$(echo "${MR_LIST}" |
    sed "/${OLD_VERSION_MR}/q" | sed '$d')
REGULAR_MRS=$(echo "${RELEASE_MRS}" | grep -v BREAKING) || true
if [[ $(echo "${RELEASE_MRS}" | grep BREAKING) ]] ; then
  BREAKING_MRS="
BREAKING CHANGES:
$(echo "${RELEASE_MRS}" | grep BREAKING | sed -E 's/\(BREAKING\)| \| BREAKING//g')"
  if [[ ! -z ${REGULAR_MRS:-} ]] ; then
  REGULAR_MRS="

REGULAR CHANGES:
$(echo "${REGULAR_MRS}")"
  fi
fi

# with MR_LIST figured out, and branch clear to create, do the thing
git checkout -b "release/v${NEW_RELEASE}"
echo && echo_cyan "Cutting release: ${OLD_RELEASE} -> ${NEW_RELEASE}"
update_version ${NEW_RELEASE}
echo && echo_cyan "Setting version to ${POST_RELEASE} post-release."
update_version ${POST_RELEASE}
echo

# print out the MRs since 'glab mr create' can't take a multiline description
echo_green "The following is the list of MRs for this week's release;"
echo_green "copy/paste them into your editor when prompted by 'glab mr create':"

echo "$(cat <<EOF
$(echo "${BREAKING_MRS}" | sed -E 's/^(- \#[0-9]+) .+$/\1/g')
$(echo "${REGULAR_MRS}" | sed -E 's/^(- \#[0-9]+) .+$/\1/g')
EOF
)"

${GIT_DIR}/bin/gitlab-mr -t "Release v${NEW_RELEASE}" -g devops

echo run glab release create v${NEW_RELEASE} -N "$(cat <<EOF
${BREAKING_MRS}
${REGULAR_MRS}
EOF
)"
