#!/usr/bin/env ruby
Dir.chdir(File.dirname(__FILE__)) { require 'bundler/setup' }

require 'active_support/core_ext/integer/time'
require 'aws-sdk-cloudwatchlogs'
require 'concurrent-ruby'
require 'csv'
require 'json'
require 'optparse'
require 'optparse/time'

class QueryCloudwatch
  Config = Struct.new(
    :logs,
    :groups,
    :slice,
    :env,
    :app,
    :start,
    :to,
    :query,
    :format,
    keyword_init: true
  )

  def run(argv, stdin)
    config = parse(argv, stdin)

    query_all(config)
  end

  def query_all(config)
    errors = Concurrent::Array.new
    thread_pool = Concurrent::FixedThreadPool.new(5)

    config.groups.each do |group|
      time_ranges(config).each do |from, to|
        thread_pool.post do
          begin
            STDERR.puts "QUERY START: #{group} (#{from}...#{to})"
            result = query_one(from: from, to: to, group: group, query: config.query)

            puts format_response(result, config.format)
          rescue => e
            errors << e
            thread_pool.shutdown
          end
        end
      end
    end

    thread_pool.shutdown
    thread_pool.wait_for_termination

    if !errors.empty?
      STDERR.puts errors
      exit 1
    end
  end

  # @param [Aws::CloudWatchLogs::Types::GetQueryResultsResponse] response
  # @return [Array<String>]
  def format_response(response, fmt)
    case fmt
    when :csv
      response.results.map do |row|
        row.reject { |cell| cell[:field] == "@ptr" }.
          map { |cell| cell[:value] }.
          to_csv
      end
    when :json
      response.results.map do |row|
        h = Hash[row.map { |cell| [cell[:field], cell[:value]]}]
        h.delete("@ptr") # just noise
        h.to_json
      end
    else
      puts "unknown format #{fmt}"
      exit 1
    end
  end

  def cloudwatch_client
    @cloudwatch_client ||= Aws::CloudWatchLogs::Client.new(region: ENV['AWS_REGION'])
  end

  # @return [Aws::CloudWatchLogs::Types::GetQueryResultsResponse] result
  def query_one(from:, to:, group:, query:)
    query_id = cloudwatch_client.start_query(
      start_time: from.to_i,
      end_time: to.to_i,
      log_group_name: group,
      query_string: query,
    ).query_id

    loop do
      sleep 3
      response = cloudwatch_client.get_query_results(query_id: query_id)
      return response if response.status == 'Complete'
    end
  end

  # @return [Array<Array(Time, Time)>]
  def time_ranges(config)
    ranges = []
    current = config.start

    while current < config.to
      next_val = current + config.slice

      ranges << [
        current,
        next_val,
      ]

      current = next_val
    end

    ranges
  end

  # @return [Config]
  def parse(argv, stdin)
    config = Config.new(
      logs: [],
      groups: [],
      slice: parse_duration('1w'),
      format: :csv,
      to: Time.now,
    )

    OptionParser.new do |opts|
      opts.banner = <<~TXT
        Usage
        =======================

          #{$PROGRAM_NAME} [OPTIONS]

        Script to query cloudwatch, splits a query up across multiple timeframes and combines
        results (useful for querying a log period of time)

        Examples
        =======================

        Query last 7 days shorthand with multiple logs, query in STDIN

        #{$PROGRAM_NAME} --from 7d --env int --app idp --log events.log,production.log <<QUERY
          fields @timestamp
          | limit 9999
        QUERY

        Query full log group, full timestamps, query as an arugment

        #{$PROGRAM_NAME} \\
          --group int_/srv/idp/shared/log/production.log \\
          --start "2020-01-01T00:00:00-00:00" \\
          --to "2020-12-31T23:59:59-00:00" \\
          --query "fields @timestamp | limit 9999"

        Timestamps
        =======================

        * Can be anything Ruby's Time.parse understands:

          "2021-01-01T00:00:00-07:00"
          "2021-01-01 00:00:00 -0700"

        * Can be represented as duration shorthands:

          10m - 10 minutes ago
          9h  - 9 hours ago
          8d  - 8 days ago
          7w  - 7 weeks ago
          6m  - 6 months ago
          5y  - 5 years ago

        Options
        =======================
      TXT

      opts.on('--env ENV', '(optional)') do |env|
        config.env = env
      end

      opts.on('--app APP', '(optional)') do |app|
        config.app = app
      end

      opts.on('--log LOG,LOG', 'shorthand log groups (ex "events.log"), needs --app and --env') do |logs|
        config.logs += [logs]
      end

      opts.on('--group GROUP,GROUP', 'shorthand log groups (ex "int_/srv/idp/shared/log/production.log")') do |groups|
        config.groups += [groups]
      end

      opts.on('--from STR', '--start STR', 'query start, see Timestamps above for examples') do |str|
        if (duration = parse_duration(str))
          config.start = duration.ago
        else
          config.start = Time.parse(str)
        end
      end

      opts.on('--to STR', '--end STR', '(optional, defaults to now) query end, see Timestamps above for examples') do |str|
        if (duration = parse_duration(str))
          config.to = duration.ago
        else
          config.to = Time.parse(str)
        end
      end

      opts.on('--query QUERY', 'Cloudwatch Insights query') do |query|
        config.query = query
      end

      opts.on('--slice SLICE', 'query slice size duration, defaults to 1w') do |slice|
        config.slice = parse_duration(slice)
      end

      opts.on('--json', 'format output as newline-delimited JSON (nd-json)') do
        config.format = :json
      end

      opts.on('--csv', '(default) format output as CSV') do
        config.format = :csv
      end

      opts.on("-h", "--help", "Prints this help") do
        puts opts
        exit
      end
    end.parse!(argv)

    if (app = config.app) && (env = config.env) && !(logs = config.logs).empty?
      logs.each do |log|
        config.groups << build_group(app: app, env: env, log: log)
      end
    end

    errors = []

    if config.groups.empty?
      errors << "ERROR: missing log groups --group or (--app and --env and --log)"
    end

    if !config.start
      errors << "ERROR: missing time range --from or --start"
    end

    if !config.query
      if stdin.tty?
        errors << "ERROR: missing query, either STDIN or --query)"
      else
        config.query = STDIN.read
      end
    end

    if !errors.empty?
      puts errors
      exit 1
    end

    config
  end

  # @param [String] log ex production.log
  # @param [String] app ex idp
  # @param [String] env ex int
  def build_group(log:, app:, env:)
    "#{env}_/srv/#{app}/shared/log/#{log}"
  end

  # @param [String] value a string such as 1m, 2h, 3d, 4w, 5m, 6y
  # @return [ActiveSupport::Duration]
  def parse_duration(value)
    if (match = value.match(/^(?<number>\d+)(?<duration>\D)$/))
      number = Integer(match[:number], 10)

      duration = case match[:duration]
      when 'm'
        number.minutes
      when 'h'
        number.hours
      when 'd'
        number.days
      when 'w'
        number.weeks
      when 'm'
        number.months
      when 'y'
        number.years
      end

      return duration if duration
    end
  end
end

if __FILE__ == $PROGRAM_NAME
  QueryCloudwatch.new.run(ARGV, STDIN)
end
