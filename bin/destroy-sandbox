#!/bin/bash

#### Tear down/destroy a sandbox environment ####

set -euo pipefail

BASEPATH="$(dirname "$0")"
. "${BASEPATH}/lib/common.sh"
. "${BASEPATH}/lib/sandbox-lib.sh"

trap replace_db_files EXIT

usage() {
  cat >&2 << EOM

Usage: ${0} [-dpbxk12345[a]h] [TF_ENV] (will use \$GSA_USERNAME if not specified)

Flags (will run all if no flags specified):
  -d / -1 : Remove deletion protection from RDS + zero out ASGs via targeted apply
  -p / -2 : Delete the DS record for the pivcac.ENV.identitysandbox.gov hosted zone
  -b / -3 : Empties all S3 buckets with ENV in the bucket name
  -x / -4 : terraform-destroy + reset db .tf files
  -k / -5 : Delete all ENV-named S3 keys in secrets/app-secrets buckets
       -a : Same as -d, but do full (non-targeted) apply (not run by default)
       -h : Detailed help

EOM
}

help_me() {
  cat >&2 << EOM

Usage: ${0} [-dcpbxk123456[a]h] [TF_ENV] (will use \$GSA_USERNAME if not specified)

Runs all necessary commands to prep and destroy an existing sandbox environment,
\${TF_ENV}. Designed to run with no specified flags/arguments.

The tasks in this script can also be individually executed as follows:

  -d / -1 : Remove protection/prevent_destroy/final_snapshot from RDS databases, and
            zero out Auto Scaling Groups, via a targeted \`tf-deploy\` operation.
            (Step: 1_allow_db_destroy)
  -p / -2 : Delete the DS record from identitysandbox.gov that enables DNSSEC for the
            pivcac.\${TF_ENV}.identitysandbox.gov (necessary before disabling DNSSEC)
            (Step: 2_destroy_pivcac_ds_records)
  -b / -3 : Empties all S3 buckets with \${TF_ENV} in the bucket name,
            and deletes all object versions as well
            (Step: 3_empty_buckets)
  -x / -4 : Run \`terraform destroy -auto-approve\` against the
            environment, skipping the attempt to send a message to Slack
            (Step: 4_tf_destroy)
  -k / -5 : Delete all S3 keys in the secrets/app-secrets buckets that
            have \${TF_ENV} in their name
            (Step: 5_delete_env_keys)
       -a : Same as -d but do a full \`apply\` without specifically targeting the
            RDS databases/ASGs (use in case the targeted \`apply\` is failing).
       -h : Displays this help

This script will default to using \${GSA_USERNAME} for the
value of \${TF_ENV}, unless a different one is specified
as a final argument.

EOM
  exit 0
}

1_allow_db_destroy() {
  local TF_ARGS=()
  if [[ ! ${APPLY_ALL} == true ]] ; then
    TF_ARGS=($(ave ${BASEPATH}/tf-deploy ${TF_ENV} app state list |
      grep 'db_instance\|autoscaling_group\|rds_cluster\.'))
    TF_ARGS+=('aws_route53_record.pivcac_zone_ds') # delete pivcac parent DS
    TF_ARGS=( "${TF_ARGS[@]/#/-target=}" ) # adds DBs and ASGs as targets
  fi
  ave ${BASEPATH}/tf-deploy -z -t ${TF_ENV} app apply -auto-approve "${TF_ARGS[@]:-}"
}

2_destroy_pivcac_ds_records() {
  local ZONE_ID=$(ave aws route53 list-hosted-zones-by-name |
              jq -r '.HostedZones[]|select(.Name == "identitysandbox.gov.").Id' |
              awk -F/ '{print $NF}')
  local PIVCAC_DS=$(ave aws route53 list-resource-record-sets \
       --hosted-zone-id $ZONE_ID |
       jq -c --arg ENV_NAME "${TF_ENV}" \
       '.ResourceRecordSets[]|select(.Type == "DS")|select(.Name|contains($ENV_NAME))')
  if [[ -z ${PIVCAC_DS} ]] ; then
    echo_yellow "No DS record found for pivcac.${TF_ENV} ; skipping"
  else
    ave aws route53 change-resource-record-sets \
        --hosted-zone-id $ZONE_ID \
        --change-batch \
        "{\"Comment\":\"DEL-pivcac.${TF_ENV}-DS\",\"Changes\":[{\"Action\":\"DELETE\",\"ResourceRecordSet\":$PIVCAC_DS}]}"
  fi
}

3_empty_buckets() {
  for BUCKET in $(ave aws s3 ls | grep ${TF_ENV} | awk '{print $NF}' | sort -r); do
    BUCKET_REGION=$(echo ${BUCKET} | sed -E 's/.*[0-9]+\-//')
    empty_bucket_with_versions ${BUCKET} ${BUCKET_REGION}
  done
}

4_tf_destroy() {
  ave ${BASEPATH}/tf-deploy -t ${TF_ENV} app destroy -auto-approve
  replace_db_files
}

5_delete_env_keys() {
  local OBJECTS
  for BUCKET in $(ave aws s3 ls | grep 'secrets.' | awk '{print $NF}') ; do
    OBJECTS_JSON=$(ave aws s3api list-object-versions \
      --bucket ${BUCKET} --output=json \
      --query='{Objects: Versions[].{Key:Key,VersionId:VersionId}}')
    if [[ $(echo "${OBJECTS_JSON}" | jq -r '.Objects') != "null" ]] ; then
      OBJECTS=$(echo "${OBJECTS_JSON}" | jq --arg name "${TF_ENV}" \
        '{Objects:[.[][]|select(.Key|contains($name))|
          {Key, VersionId}],Quiet: false}')
      if [[ ! -z $(echo "${OBJECTS}" | jq '.Objects[]') ]] ; then
        ave aws s3api delete-objects --bucket ${BUCKET} \
          --delete "$(echo "${OBJECTS}" | jq)"
      fi
    fi
    if [[ $(ave -r aws s3 ls "s3://${BUCKET}/${TF_ENV}") ]] ; then
      BUCKET_REGION=$(echo ${BUCKET} | sed -E 's/.*[0-9]+\-//')
      empty_bucket_with_versions "${BUCKET}/${TF_ENV}" ${BUCKET_REGION}
    fi
  done
}

TASKS=(
  "1_allow_db_destroy"
  "2_destroy_pivcac_ds_records"
  "3_empty_buckets"
  "4_tf_destroy"
  "5_delete_env_keys"
)

TODO=()
APPLY_ALL=false
while getopts d1p2b3x4k5ah opt
do
  case $opt in
    d|1) TODO+=("${TASKS[0]}") ;;
    p|2) TODO+=("${TASKS[1]}") ;;
    b|3) TODO+=("${TASKS[2]}") ;;
    x|4) TODO+=("${TASKS[3]}") ;;
    k|5) TODO+=("${TASKS[4]}") ;;
    a) APPLY_ALL=true          ;;
    h) help_me                 ;;
    *) usage && exit 1         ;;
  esac
done
shift $((OPTIND-1))

initialize ${1:-}
remove_db_protection_in_state 'ALL'

if [[ ${APPLY_ALL} == true ]] ; then
  if [[ ! -z ${TODO-} ]] && [[ ! "${TODO[@]:-}" =~ "${TASKS[0]}" ]] ; then
    TODO+=("${TASKS[0]}")
  fi
fi
run_tasks
