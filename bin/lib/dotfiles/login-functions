#!/bin/bash

############# login.gov aliases/functions #############
if [[ ! $(brew cask list | grep aws-vault) ]] ; then
  brew cask install aws-vault || { echo "aws-vault not installed!" && exit 1 ; }
fi

######## aliases ########
alias bb="git checkout stages/${GSA_USERNAME}"
alias laptop='bash <(curl -s https://raw.githubusercontent.com/18F/laptop/master/laptop)'

######## sub-functions ########
## print full command before running ##
USE_RUN=1
run() {
  if [[ $USE_RUN -gt 0 ]] ; then
    if [ -t 1 ]; then
      echo -ne "\\033[1;36m"
    fi

    echo >&2 "+ $*"

    if [ -t 1 ]; then
      echo -ne '\033[m'
    fi
  fi
  "$*"
}

## print $usage and return 1 ##
badopt() {
  echo "Usage: ${usage}"
  break 1
}

## determine env (and AWS_PROFILE) from arg ##
env_get() {
  AV_PROFILE='sandbox-fulladmin'
  EC2_ENV=${1:-$(echo $GSA_USERNAME)}
  [[ "${EC2_ENV}" =~ "staging|prod" ]] && AV_PROFILE='prod-fulladmin'
}

## integrates with ykman for YubiKey OTP MFA ##
mfa_get() {
  ttl_time=$(aws-vault list --sessions | awk '{print $1}')
  if [[ -z ${ttl_time} ]] || [[ ${ttl_time} -lt $(date +%s) ]] ; then
    ttl="--duration=1h"
    [[ $(command -v ykman) ]] && yk="--mfa-token=$(ykman oath code --single aws/login-master | awk '{print $NF}')"
  fi
}

## strip off aws-vault exec stuff if running a long AWS_VAULT session ##
run_av() {
  if [[ -z ${AWS_VAULT} ]] ; then
    declare {ttl,yk}=
    mfa_get
    run aws-vault exec ${AV_PROFILE} ${ttl} ${yk} -- "$@"
  else
    run "$@"
  fi
}

######## core functions ########
#### fast aws-vault commands ####
av() {
  read -r -d '' usage <<'EOF'
TBD
EOF
  [[ $# == 0 ]] && badopt
  while getopts i:l:s:p:a:o:m: opt
  do
    case "${opt}" in          ## profile in aws-vault exec ${profile}
      i) AV_PROFILE='sandbox-fulladmin'     ;;
      l) AV_PROFILE='prod-fulladmin'        ;;
      s) AV_PROFILE='sms-sandbox-fulladmin' ;;
      p) AV_PROFILE='sms-prod-fulladmin'    ;;
      a) AV_PROFILE='analytics-fulladmin'   ;;
      o) AV_PROFILE='secops-fulladmin'      ;;
      m) AV_PROFILE='master-fulladmin'      ;;
    h|*) badopt                             ;;
    esac
    AV_CMD="${OPTARG}"
  done
  shift
  declare {ttl,yk}=
  mfa_get
  case "${AV_CMD}" in
    l) run aws-vault login ${AV_PROFILE} ${ttl} ${yk} ;;
    c) run_av "$@" ;;
    *) badopt ;;
  esac
}

#### run tf-deploy with common Terraform commands and any AWS profile/TF directory ####
td() {
  read -r -d '' usage <<'EOF'

TBD

EOF
  [[ $# == 0 ]] && badopt
  while getopts apd opt
  do
    case $opt in
      a) TF_CMD='apply'   ;;
      p) TF_CMD='plan'    ;;
      d) TF_CMD='destroy' ;;
      *) badopt ${opt}    ;;
    esac
  done
  shift
  TF_DIR="${1-app}"
  shift
  EC2_ENV="${1-sandbox}"
  case $TF_DIR in
    all|core) AV_PROFILE="${EC2_ENV}-fulladmin" ;;
    app) env_get "${1}" ;;
    master)
      AV_PROFILE='master-fulladmin'
      EC2_ENV="global"
    ;;
    sms) AV_PROFILE="sms-${EC2_ENV}-fulladmin" ;;
  esac
  if [[ "${TF_DIR}" == 'app' ]] ; then
    run_av tf-deploy ${EC2_ENV} terraform-${TF_DIR} ${TF_CMD}
  else
    run_av tf-deploy terraform-${TF_DIR}/${EC2_ENV} ${TF_CMD}
  fi
}

#### run terraform plan with trimmed-down output ####
tpc() {
  plan=$(td -p "${@}")
  echo $plan | sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g' |
               grep --color=auto -E '(^\s+[-\#\+\~\>]|\s->)\s' |
               sed -E 's/(user_data += ").*"/\1\*"/'
}

#### quick SSM access ; requires session-manager-plugin to work! ####
ssc() {
  local SSM_CMD
  while getopts ifs opt
  do
    case $opt in
      i) SSM_CMD="sudo su - ${GSA_USERNAME}" ;;
      f) SSM_CMD="sudo tail -f /var/log/cloud-init-output.log" ;;
      s) SSM_CMD="sudo su - " ;;
    esac
  done
  shift
  INSTANCE_ID=${1}
  env_get "${2}"
  run_av aws ssm start-session \
      --document-name AWS-StartInteractiveCommand \
      --parameters command="'${SSM_CMD}'" \
      --target "${INSTANCE_ID}"
}

#### run bundle exec with common commands ####
be() {
  read -r -d '' usage <<'EOF'

TBD

EOF
  [[ $# == 0 ]] && badopt
  local BUNDLE_CMD
  AV_PROFILE='sandbox-fulladmin'
  while getopts vk:b:r: opt
  do
    case "${opt}" in       ## opt in `be -${opt}${OPTARG}`
      k) case "${OPTARG}" in
          t) BUNDLE_CMD='kitchen test'     ;;
          c) BUNDLE_CMD='kitchen converge' ;;
          l) BUNDLE_CMD='kitchen login'    ;;
          i) BUNDLE_CMD='kitchen list'     ;;
          d) BUNDLE_CMD='kitchen destroy'  ;;
          v) BUNDLE_CMD='kitchen verify'   ;;
          o) BUNDLE_CMD='kitchen console'  ;;
          *) badopt                        ;;
         esac
      ;;
      b) case "${OPTARG}" in
          u) BUNDLE_CMD='berks update'  ;;
          i) BUNDLE_CMD='berks install' ;;
          *) badopt                     ;;
         esac
      ;;
      r) case "${OPTARG}" in
          k) BUNDLE_CMD='rake'    ;;
          c) BUNDLE_CMD='rails c' ;;
          s) BUNDLE_CMD='rspec'   ;;
          *) badopt               ;;
         esac
      ;;
      h|*) badopt ${opt} ;;  
    esac
  done
  run_av bundle exec ${BUNDLE_CMD}
} 


#### quickly run common cloudlib aliases/commands with any AWS_PROFILE/env ####
vcl () {
  read -r -d '' usage <<'EOF'

TBD
 
EOF
  [[ $# == 0 ]] && badopt
  env_get ${2}
  while getopts el:c:r:s: opt
  do
    case "${OPTARG}" in
      A) EC2_TYPE='ALL'                     ;;
      a) EC2_TYPE='app'                     ;;
      e) EC2_TYPE='elasticsearch'           ;;
      i) EC2_TYPE='idp'                     ;;
      j) EC2_TYPE='jumphost'                ;;
      k) EC2_TYPE='elk'                     ;;
      m) EC2_TYPE='migration'               ;;
      o) EC2_TYPE='outboundproxy'           ;;
      p) EC2_TYPE='pivcac'                  ;;
      *) [[ ${opt} =~ 'e' ]] || badopt ${1} ;;
    esac
    case "${opt}" in
      e) CL_TABLE=$(run_av ls-servers -Hlqe ${EC2_ENV})                 ;;
      l) CL_TABLE=$(run_av ls-servers -Hlqn asg-${EC2_ENV}-${EC2_TYPE}) ;;
      c) run_av scale-in-old-instances -q ${EC2_ENV} ${EC2_TYPE}        ;;
      r) run_av asg-recycle -q ${EC2_ENV} ${EC2_TYPE}                   ;;
      s) run asg-size -q ${EC2_ENV} ${EC2_TYPE} ${3-}                   ;;
      *) badopt ${opt}                                                  ;;
    esac
  done
  [[ -z "${CL_TABLE}" ]] || echo "${CL_TABLE}" |
                            sed '1d;$d;s/\|/ /g;s/asg\-//g' |
                            awk '{print $1, $2, $3, $4, $6, $12}' |
                            column -t
}

#### call the cl elasticsearch commands with av() ####
ve() {
  read -r -d '' usage <<'EOF'

TBD 

EOF
  [[ $# == 0 ]] && badopt
  env_get ${2}
  while getopts sdcu opt ; do
    case "${opt}" in
      s) ES_CMD="check_status" ;;
      d) ES_CMD="drain_old_nodes" ;;
      c) ES_CMD="clear_node_drain" ;;
      u) ES_CMD="update_minimum_masters" ;;
      *) badopt ${opt} ;;
    esac
  done
  run_av cl elasticsearch ${ES_CMD} ${EC2_ENV} ${3-}
}

######## shell startup ########
for key in $(env | grep ".*SSH_KEY=" | sed 's/=.*$//') ; do
  if [ -f $(eval echo \$$key) ] ; then
    while ! ssh-add -L | grep -q $key ; do
      ssh-add -K $(eval echo \$$key)
    done
  fi
done
