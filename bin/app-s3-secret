#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'tempfile'
require 'fileutils'

Dir.chdir(File.dirname(__FILE__)) { require 'bundler/setup' }
require_relative '../cloudlib/lib/cloudlib'

def basename
  File.basename($PROGRAM_NAME)
end

def main(args)
  config = {}

  optparse = OptionParser.new do |opts|
    opts.banner = <<-EOM
usage: #{basename} [OPTIONS]

Download or upload secret files from S3

Examples:
    # RECOMMENDED: Print out idp's application.yml from int environment
    #{basename} --env int --app idp

    # RECOMMENDED: Save idp's application.yml in int to a file with a default
    # name (int.idp.application.yml)
    #{basename} --env int --app idp --download

    # Save idp's application.yml in int to a file named custom.yml
    #{basename} --env int --app idp --download custom.yml

    # RECOMMENDED: Upload a local file to s3 for idp in int from a default name
    # (int.idp.application.yml)
    #{basename} --env int --app idp --upload

    # Upload a local file to s3 for idp in int from custom filename
    #{basename} --env int --app idp --upload custom.yml

    # Upload from STDIN to s3 for idp in int
    cat int.idp.application.yml | #{basename} --env int --app idp --upload -

    # RECOMMENDED: Download file, interactively edit file in $VISUAL or $EDITOR (defaults
    # to vim), preview a diff, and then upload it
    #{basename} --env int --app idp --edit

Options:
    EOM

    opts.on('-h', '--help', 'Display this message') do
      STDERR.puts opts
      exit
    end

    opts.on('--dry-run', 'Dry run only') do
      config[:dry_run] = true
    end

    opts.on('--remote-file REMOTE_FILE', 'Specify remote filename, defaults to application.yml') do |val|
      config[:remote_file] = val
    end

    opts.on('-a', '--app APP', 'Specify APP (required)') do |val|
      config[:app] = val
    end

    opts.on('-e', '--env ENVIRONMENT', 'Specify ENVIRONMENT (required)') do |val|
      config[:env] = val
    end

    opts.on('--download [LOCAL_FILE]', 'Downloads file from S3 (defaults to local file named with environment and app, ex: int.idp.application.yml)') do |val|
      if config[:direction]
        STDERR.puts "#{basename}: can't specify both --download and --upload"
        exit 1
      end

      if config[:edit]
        STDERR.puts "#{basename}: can't specify both --download and --edit"
        exit 1
      end
      config[:direction] = :down
      config[:download_file] = val
    end

    opts.on('--upload [LOCAL_FILE]', 'Uploads file to S3 (defaults to local file named with environment and app, ex: int.idp.application.yml)') do |val|
      if config[:direction]
        STDERR.puts "#{basename}: can't specify both --download and --upload"
        exit 1
      end

      if config[:edit]
        STDERR.puts "#{basename}: can't specify both --upload and --edit"
        exit 1
      end

      config[:direction] = :up
      config[:upload_file] = val
    end

    opts.on('--edit', 'Download, interactively edit, then upload') do |val|
      if config[:direction]
        STDERR.puts "#{basename}: can't specify both --edit and --download/--upload"
        exit 1
      end

      config[:edit] = true
    end
  end

  command = optparse.order(args)

  if command.any?
    STDERR.puts optparse
    exit 1
  end

  # Default arguments
  config[:remote_file] ||= 'application.yml'

  if !config[:env]
    STDERR.puts optparse
    STDERR.puts "\n#{basename}: missing environment"
    exit 1
  end

  if !config[:app]
    STDERR.puts optparse
    STDERR.puts "\n#{basename}: missing app"
    exit 1
  end

  config[:upload_file] ||= Cloudlib::S3.app_secret_path(
    env: config[:env],
    app: config[:app],
    remote_file: config[:remote_file]
  )

  if config[:edit]
    edit!(config)
  else
    plain_download_upload!(config)
  end
end

def plain_download_upload!(config)
  # Upload/download arguments
  # 1. No argument: download to stdout
  if !config[:direction]
    config[:direction] = :down
    config[:download_file] = '-'
  elsif config[:direction] == :down
    # 2. Download, no path specific
    # 3. Download with path
    config[:download_file] ||= Cloudlib::S3.app_secret_path(
      env: config[:env],
      app: config[:app],
      remote_file: config[:remote_file]
    )
  end

  if config[:direction] == :up
    if config[:upload_file] == '-'
      if STDIN.tty?
        STDERR.puts "\n#{basename}: missing file to upload. Specified '-'but didn't pipe through STDIN"
        exit 1
      end
    elsif !File.exist?(config[:upload_file])
      STDERR.puts "\n#{basename}: missing file to upload, file named '#{config[:upload_file]}' does not exist"
      exit 1
    end
  end

  s3_path = Cloudlib::S3.app_secret_path(
    env: config[:env],
    app: config[:app],
    remote_file: config[:remote_file],
  )

  src, dest = case config[:direction]
  when :down
    log_aws_cp_command(src: "s3://#{bucket}/#{s3_path}", dest: config[:download_file])

    if !config[:dry_run]
      if config[:download_file] == '-'
        s3_client.get_object(bucket: bucket, key: s3_path) do |chunk|
          STDOUT.write(chunk)
        end
      else
        s3_client.get_object(
          bucket: bucket,
          key: s3_path,
          response_target: config[:download_file],
        )
      end
    end
  when :up
    log_aws_cp_command(src: config[:upload_file], dest: "s3://#{bucket}/#{s3_path}")

    upload_file = config[:upload_file] == '-' ? STDIN : File.new(config[:upload_file])

    s3_client.put_object(
      bucket: bucket,
      key: s3_path,
      body: config[:upload_file],
    ) if !config[:dry_run]
  else
    STDERR.puts "#{basename}: Unknown direction #{config[:direction]}"
    exit 1
  end
end

def bucket
  @bucket ||= Cloudlib::S3.load_bucket!
end

def s3_client
  @s3_client ||= Aws::S3::Client.new
end

# logs an equivalent aws command line
def log_aws_cp_command(src:, dest:)
  s3_args = ['aws', 's3', 'cp', src, dest]
  STDERR.puts s3_args.join(' ')
end

def edit!(config)
  file = Cloudlib::S3.app_secret_path(
    env: config[:env],
    app: config[:app],
    remote_file: config[:remote_file],
  )

  ext = File.extname(file)
  base = File.basename(file, ext)

  s3_path = file

  editor = ENV['VISUAL'] || ENV['EDITOR'] || `which vim`.chomp
  differ = `which colordiff`.chomp
  if !$?.success?
    differ = `which diff`.chomp
  end

  tempfile = Tempfile.new([base, ext])
  tempfile_copy = Tempfile.new([base, 'copy', ext])

  log_aws_cp_command(src: "s3://#{bucket}/#{s3_path}", dest: tempfile.path)
  s3_client.get_object(
    bucket: bucket,
    key: s3_path,
    response_target: tempfile.path,
  )

  FileUtils.copy(tempfile.path, tempfile_copy.path)

  # Split `editor` to support editors that require arguments, e.g. "code -w"
  system(*editor.split, tempfile.path)
  if !$?.success?
    STDERR.puts "#{basename}: Editor (#{editor}) did not exit successfully. Aborting"
    exit 1
  end

  if FileUtils.compare_file(tempfile.path, tempfile_copy.path)
    STDOUT.puts "#{basename}: No changes detected in file. Exiting"
    exit 0
  end

  STDOUT.puts "#{basename}: Here's a preview of your changes:"
  system(differ, tempfile_copy.path, tempfile.path)

  STDOUT.puts "#{basename}: Upload changes to S3? (y/n)"
  fd = IO.sysopen("/dev/tty", "r")
  tty_in = IO.new(fd,"r")

  input = tty_in.read(1)
  if input == 'y'
    log_aws_cp_command(src: tempfile.path, dest: "s3://#{bucket}/#{s3_path}")

    s3_client.put_object(
      bucket: bucket,
      key: s3_path,
      body: File.new(tempfile.path),
    ) if !config[:dry_run]
  else
    STDERR.puts "#{basename}: diff not approved, not uploading to S3"
  end
ensure
  tempfile.unlink
  tempfile_copy.unlink
end

if __FILE__ == $0
  main(ARGV)
end
