#!/usr/bin/env bash

# function to exit process with error message
die() { echo_red "$*" >&2 ; exit 1; }

# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail

if [ $# -lt 3 ] ; then
    echo "Usage: $0 <environment_name> <terraform_dir> [<terraform_commands>]"
    echo "   Runs <terraform_commands> against <environment_name> using the"
    echo "   configuration in <terraform_dir>."
    exit 1
fi

# shellcheck source=./bin/lib/common.sh
. "$(dirname "$0")/bin/lib/common.sh"

# Be sure ruby is working and bundler is setup since some terraform modules
# rely on erb templates and ruby to be working.
run bundle check

ORIGIN_REMOTE_NAME="${ORIGIN_REMOTE_NAME-origin}"

ENVIRONMENT=$1; shift
TF_DIR=$1; shift
TF_CMD=("$@")

TF_DIR="${TF_DIR%/}" # strip off trailing /

case "$TF_DIR" in
    terraform-dns|terraform-cloudtrail|terraform-common)
        # These configurations apply account wide, so set the environment to the
        # account ID.
        #
        # https://stackoverflow.com/a/33791322
        if [ "$ENVIRONMENT" != "global" ]; then
            echo_red >&2 "$TF_DIR applies to the whole AWS account!"
            echo_red >&2 "For safety, pass 'global' as the environment name"
            die "You provided '$ENVIRONMENT'"
        fi

        ENVIRONMENT="account_global_$(run aws sts get-caller-identity --output text --query 'Account')"
        echo >&2 "Forcing environment name to be $ENVIRONMENT since $TF_DIR is account wide configuration"
        ;;
    */?*)
        echo_red >&2 "\$TF_DIR cannot contain slashes, must be at top level"
        die "You provided '$TF_DIR'"
        ;;
esac

# We need to be in the root of the repo for all this to work.
cd "$(dirname "$0")"

check_release_versioning() {
    local strict_check rev_name
    echo "DEPLOY: Checking whether environment versioning is recommended"

    case "$TF_DIR" in
        terraform-app)
            # versioning enabled
            ;;
        *)
            # versioning not enabled
            return
            ;;
    esac

    case "$ENVIRONMENT" in
        # strict checks in these user-facing environments
        prod|staging|int)
            strict_check=1
            ;;

        # limited checks in these testing environments
        dev|qa|pt|dm)
            strict_check=
            ;;

        # no checking in other environments
        *)
            return
            ;;
    esac

    rev_name="$(git rev-parse --abbrev-ref HEAD)"
    # make sure we're on stages/$ENVIRONMENT
    if [ "$rev_name" != "stages/$ENVIRONMENT" ]; then
        echo_yellow >&2 "
warning: Current git branch is not the expected stages/$ENVIRONMENT

Environment: $ENVIRONMENT
Expected branch: stages/$ENVIRONMENT
Actual branch:   $rev_name
"

        # check is fatal for strict environments
        if [ -n "$strict_check" ] && [ -z "${DEPLOY_WEIRD_BRANCH-}" ]; then
            echo_red >&2 "error: branch name must be stages/$ENVIRONMENT"
            echo_red >&2 "set DEPLOY_WEIRD_BRANCH=1 to skip this check"
            return 2
        fi
    else
        # make sure local stages/<env> is the same as origin/stages/<env>

        # fetch latest from remote
        if ! run git fetch "$ORIGIN_REMOTE_NAME"; then
            echo_yellow >&2 "git fetch failed"
        fi

        local local_ref origin_ref
        local_ref="$(git rev-parse "stages/$ENVIRONMENT")"
        origin_ref="$(git rev-parse "$ORIGIN_REMOTE_NAME/stages/$ENVIRONMENT")"
        if [ "$local_ref" != "$origin_ref" ]; then

            echo_yellow >&2 "
Warning: Local stages branch differs from origin stages branch!
Maybe you need to git push?

stages/$ENVIRONMENT:        $local_ref
$ORIGIN_REMOTE_NAME/stages/$ENVIRONMENT: $origin_ref

You can also set ORIGIN_REMOTE_NAME if your primary git remote is named
something other than 'origin'.
"

            # check is fatal for strict environments
            if [ -n "$strict_check" ] && [ -z "${DEPLOY_WEIRD_BRANCH-}" ]; then
                echo_red >&2 "error: local and remote stages branches differ"
                echo_red >&2 "set DEPLOY_WEIRD_BRANCH=1 to skip this check"
                return 3
            fi
        fi
    fi


    if [ -n "$strict_check" ]; then
        if [[ ( "$(cat VERSION.txt)" =~ -pre ||
                ! "$(git log -n 1 --pretty=format:'%d')" =~ tag: ) ]]
        then
            echo_yellow >&2 "

###############################################################################
#                              INFORMATIONAL                                  #
###############################################################################

We would like to start using tagged release versions that we carry through
environments for user-facing environments.

The $ENVIRONMENT environment ideally should be deployed from a tagged,
non-prerelease version because it is one of the environments officially
supported by the devops team for client use.

Please consider running \`rake release\` to edit VERSION.txt and create a
tagged release.

See https://github.com/18F/identity-devops/tree/master/doc/process/releases.md
for more details about our release tools.

The current version in VERSION.txt is: $(cat VERSION.txt)

"
        fi
    fi
}

echo_blue "deploy environment: $ENVIRONMENT"

check_release_versioning

echo "DEPLOY: Loading environment variables...."
. bin/load-env.sh "$ENVIRONMENT"

if [ -z "${TF_VAR_account_id-}" ]; then
    echo_red >&2 "Expected to find TF_VAR_account_id in private env"
    exit 1
fi

if [ -n "$MOVED_TO_TFVARS" ]; then
    echo >&2 "Looks like this environment has switched to using .tfvars files"

    # read a list of .tfvars files printed by get-tfvars-for-env
    tfvars_names="$(bin/get-tfvars-for-env "$TF_VAR_account_id" "$ENVIRONMENT")"

    # render an array prefixing each filename with -var-file
    # in bash 4 we could use mapfile instead
    tf_vars_opts=()
    while IFS= read -r line; do
        tf_vars_opts+=( "-var-file" "$line" )
    done <<< "$tfvars_names"
fi

# Check that current version of terraform is supported by our environment. This
# array should be set in the environment-specific variables.
check_terraform_version "${ID_SUPPORTED_TERRAFORM_VERSIONS[@]}"

# Check that the account ID is correct
real_account_id="$(run aws sts get-caller-identity --output text --query 'Account')"
# shellcheck disable=SC2154
if [ "$real_account_id" != "$TF_VAR_account_id" ]; then
    echo_red "Account ID from environment does not match actual account"
    echo_red "TF_VAR_account_id: $TF_VAR_account_id"
    echo_red "Actual account ID: $real_account_id"
    echo_red "Are you sure you set AWS_PROFILE / secret key right?"
    die "error: Account ID mismatch"
fi

STATE=${TF_DIR}/terraform-${TF_VAR_env_name}.tfstate
case "$TF_DIR" in
    terraform-dns|terraform-cloudtrail|terraform-common)
        echo "Not using a region specific state file for dns remote config"
        STATE=${TF_DIR}/terraform.tfstate
        ;;
esac
echo "Using state file $STATE"

echo "Ensuring ${TF_DIR} is a terraform directory"
if [ ! -f "${TF_DIR}/main.tf" ] ; then
    echo_red "deploy: not found: '${TF_DIR}/main.tf'"
    echo_red "Are you sure '${TF_DIR}' is a terraform project folder?"
    echo_red "Known examples include terraform-app, etc."
    die "error: Could not find terraform files"
fi

echo "Configuring state bucket login_dot_gov_tf_state with state path ${STATE}"
if [ -z "${TERRAFORM_STATE_BUCKET:=}" ] ; then
    die "You must set the TERRAFORM_STATE_BUCKET environment variable.  \
This should contain the name of the s3 bucket used to store terraform state for this run."
fi

if [ -z "${TERRAFORM_STATE_BUCKET_REGION:=}" ] ; then
    die "You must set the TERRAFORM_STATE_BUCKET_REGION environment variable.  \
This should contain the region of the s3 bucket used to store terraform state for this run."
fi

if [ -z "${ID_state_lock_table-}" ]; then
    die "Must set ID_state_lock_table to dynamodb terraform state locking table"
fi

run bin/configure_state_bucket.sh "$TERRAFORM_STATE_BUCKET" "$STATE" \
    "$TF_DIR" "$TERRAFORM_STATE_BUCKET_REGION" "$ID_state_lock_table"

echo >&2 "+ cd $TF_DIR"
cd "$TF_DIR"

cat <<EOF
########################################
#
# Working in environment:
# $TF_VAR_env_name
#
########################################

EOF

echo_blue "Running terraform..."
echo

# If we are using variables from .tfvars files, splice in the -var-file options
# after the first element in TF_CMD, which will be the terraform command like
# plan/apply etc. (Only do this for terraform subcommands that accept
# -var-file.)
if [ -n "$MOVED_TO_TFVARS" ]; then
    tf_subcommand="${TF_CMD[0]-}"

    # these are the subcommands that accept -var-file
    case "$tf_subcommand" in
        apply|destroy|import|plan|refresh|validate)
            TF_CMD=(
                "$tf_subcommand" "${tf_vars_opts[@]}" "${TF_CMD[@]:1}"
            )
            ;;
    esac
fi

run terraform get
run terraform "${TF_CMD[@]}"
